
# Microsoft SQL Server

## Основи
- [Вступ до курсу Microsoft SQL Server](#вступ-до-курсу-microsoft-sql-server)
- [Вступ до баз даних та SQL](#вступ-до-баз-даних-та-sql)
- [Встановлення Microsoft SQL Server](#встановлення-microsoft-sql-server)

## Основи SQL
- [SQL SELECT: Основи роботи з запитами](#sql-select-основи-роботи-з-запитами)
- [SQL DISTINCT: Робота з унікальними значеннями](#sql-distinct-робота-з-унікальними-значеннями)
- [Тимчасові таблиці в SQL Server](#тимчасові-таблиці-в-sql-server)
- [Використання WHERE в SQL](#використання-where-в-sql)
- [Використання ORDER BY в SQL](#використання-order-by-в-sql)
- [Оператори ORDER BY, AND та OR в SQL](#оператори-order-by-and-та-or-в-sql)
- [Оператори NOT, BETWEEN та IN в SQL](#оператори-not-between-та-in-в-sql)

## Маніпуляція даними
- [Оператор INSERT INTO в SQL](#оператор-insert-into-в-sql)
- [Робота з NULL значеннями в SQL](#робота-з-null-значеннями-в-sql)
- [Оператор UPDATE в SQL](#оператор-update-в-sql)
- [Оператори DELETE, DROP та TRUNCATE в SQL](#оператори-delete-drop-та-truncate-в-sql)
- [Коментарі та вибірка TOP записів в SQL](#коментарі-та-вибірка-top-записів-в-sql)

## Агрегатні функції
- [Агрегатні функції SQL - MAX та GROUP BY](#агрегатні-функції-sql---max-та-group-by)
- [Функція MIN в SQL](#функція-min-в-sql)
- [Агрегатні функції SQL - SUM, AVG та COUNT](#агрегатні-функції-sql---sum-avg-та-count)
- [Оператор GROUP BY в SQL](#оператор-group-by-в-sql)
- [Практичне використання GROUP BY в SQL](#практичне-використання-group-by-в-sql)
- [Оператор HAVING в SQL](#оператор-having-в-sql)
- [Порівняння WHERE та HAVING в SQL](#порівняння-where-та-having-в-sql)

## Об'єднання таблиць
- [INNER JOIN в SQL](#inner-join-в-sql)
- [Практичне використання INNER JOIN в SQL Server](#практичне-використання-inner-join-в-sql-server)
- [LEFT JOIN в SQL](#left-join-в-sql)
- [Практичне використання LEFT JOIN в SQL Server](#практичне-використання-left-join-в-sql-server)
- [RIGHT JOIN в SQL](#right-join-в-sql)
- [Практичне використання RIGHT JOIN в SQL Server](#практичне-використання-right-join-в-sql-server)
- [LEFT ANTI JOIN та RIGHT ANTI JOIN в SQL](#left-anti-join-та-right-anti-join-в-sql)
- [Практичне застосування LEFT та RIGHT ANTI JOIN в SQL](#практичне-застосування-left-та-right-anti-join-в-sql)
- [FULL OUTER JOIN в SQL](#full-outer-join-в-sql)
- [SELF JOIN в SQL](#self-join-в-sql)
- [Оператори UNION та UNION ALL в SQL](#оператори-union-та-union-all-в-sql)

## Розширені запити
- [Оператор LIKE та шаблони пошуку в SQL](#оператор-like-та-шаблони-пошуку-в-sql)
- [Оператор CASE в SQL](#оператор-case-в-sql)
- [Вкладені оператори CASE в SQL](#вкладені-оператори-case-в-sql)
- [Підзапити в SQL](#підзапити-в-sql)

## Типи даних і обмеження
- [Типи даних в SQL Server](#типи-даних-в-sql-server)
- [Створення таблиць та вставка даних в SQL](#створення-таблиць-та-вставка-даних-в-sql)
- [Вставка множинних записів в SQL](#вставка-множинних-записів-в-sql)
- [Обмеження типів даних при вставці в SQL](#обмеження-типів-даних-при-вставці-в-sql)
- [Копіювання даних між таблицями в SQL](#копіювання-даних-між-таблицями-в-sql)
- [Обмеження NOT NULL в SQL](#обмеження-not-null-в-sql)
- [Обмеження UNIQUE в SQL](#обмеження-unique-в-sql)
- [Обмеження CHECK в SQL](#обмеження-check-в-sql)





# SQL: Course Introduction & Overview 

# Вступ до курсу Microsoft SQL Server

## Огляд навчальної програми

### 1. Основи SQL
- Основи оператора SELECT
- Використання SELECT DISTINCT
- Операції GROUP BY
- Реалізація підзапитів
- Види операцій JOIN
  - Розуміння різних типів об'єднань
  - Практичне застосування

### 2. Просунутий SQL
- Збережені процедури
- Представлення (Views)
- Загальні табличні вирази (CTE)
- Індексація бази даних
- Просунуті концепції баз даних

### 3. Функції SQL
- Віконні функції
  - Впровадження та практичне використання
- Службові функції
  - Функція COALESCE
  - Функція ISNULL
  - Додаткові функції SQL

### 4. Підготовка до співбесіди
1. Питання з базових концепцій
   - Практичні завдання з основ SQL
   - Розуміння основних концепцій
   - Типові сценарії співбесіди

2. Просунуті питання для співбесіди
   - Складні задачі SQL
   - Реальні питання з співбесід
   - Практичні сценарії розв'язання проблем

### 5. Практичні проекти
1. Інтеграція SQL Server з Power BI
   - Використання Microsoft SQL Server як джерела даних
   - Інтеграція з Power BI
   - Наскрізний робочий процес проекту
   - Повне виконання проекту

## Додаткові можливості
- Постійне оновлення навчальної програми
- Актуальний для індустрії контент
- Матеріали, орієнтовані на співбесіду
- Практичні вправи

## Результати навчання
Після завершення цього курсу студенти зможуть:
- Опанувати основи та просунуті концепції SQL
- Працювати зі складними операціями баз даних
- Інтегрувати SQL Server з Power BI
- Ефективно готуватися до технічних співбесід
- Виконувати наскрізні проекти з аналізу даних

*Примітка: Навчальна програма регулярно оновлюється та вдосконалюється для підтримки актуальності відповідно до вимог галузі та стандартів співбесіди.*

# Вступ до баз даних та SQL

## 1. Що таке база даних?
- Організована колекція даних, що зберігається та доступна електронно
- Цифрова система зберігання, де інформація зберігається структуровано
- Контейнер для збереження необроблених фактів і цифр

### Переваги баз даних:
1. Структуроване зберігання:
   - Дані зберігаються у специфічному форматі (таблиці з рядками та стовпцями)
   - Спрощений процес запитів та аналізу даних

2. Узгодженість:
   - Однотипні дані зберігаються однаково в усій базі даних

3. Цілісність:
   - Забезпечує точність та надійність даних
   - Важливо для прийняття рішень на основі даних

4. Масштабованість:
   - Можливість зростання без проблем з продуктивністю
   - Здатність обробляти великі обсяги даних

## 2. Система управління базами даних (СУБД)
- Програмне забезпечення для створення, управління та взаємодії з базами даних
- Виступає посередником між користувачем і базою даних
- Забезпечує операції: отримання, вставки, оновлення та видалення даних

## 3. Реляційна система управління базами даних (РСУБД)
### Основні характеристики:
- Зберігає дані у структурованому форматі (рядки та стовпці)
- Має зв'язки між таблицями
- Ефективне управління та запити даних

### Ключові елементи:
1. Таблиці:
   - Основна структура зберігання даних
   - Складаються з рядків і стовпців

2. Первинний ключ:
   - Унікальний ідентифікатор для кожного рядка

3. Зовнішній ключ:
   - Встановлює зв'язки між таблицями

4. Нормалізація:
   - Організація даних для мінімізації надлишковості
   - Оптимізація залежностей

## 4. Структурована мова запитів (SQL)
### Визначення:
- Стандартна мова програмування для управління реляційними базами даних
- Використовується для запитів, вставки, оновлення та видалення даних

### Компоненти SQL:
1. DQL (Data Query Language):
   - Мова запитів даних
   - Приклад: оператор SELECT

2. DML (Data Manipulation Language):
   - Мова маніпулювання даними
   - Операції: INSERT, UPDATE, DELETE

3. DDL (Data Definition Language):
   - Мова визначення даних
   - Створення, зміна, видалення структур бази даних

4. DCL (Data Control Language):
   - Мова контролю доступу
   - Надання та відкликання прав доступу

5. TCL (Transaction Control Language):
   - Мова керування транзакціями
   - Операції: COMMIT, ROLLBACK
   - Забезпечення цілісності даних

*Примітка: Цей матеріал є вступним і буде розширено в наступних лекціях курсу.*


# Встановлення Microsoft SQL Server: Покрокова інструкція

## Вибір редакції SQL Server

### Доступні редакції:
1. Developer Edition
   - Повнофункціональна безкоштовна версія
   - Ліцензована для розробки та тестування
   - Призначена для непромислового середовища

2. Express Edition
   - Безкоштовна версія
   - Ідеальна для розробки та впровадження
   - Підходить для настільних, веб- та малих серверних додатків

## Процес встановлення

### 1. Встановлення SQL Server:
- Завантаження Developer Edition
- Запуск виконуваного файлу
- Вибір базового встановлення
- Прийняття умов ліцензії
- Очікування завершення встановлення

### 2. Встановлення SQL Server Management Studio (SSMS):
- Перехід за посиланням для завантаження SSMS
- Запуск установки SSMS
- Очікування завершення встановлення компонентів

## Налаштування з'єднання

### Запуск SSMS:
1. Пошук SQL Server Management Studio в меню Пуск
2. Налаштування підключення:
   - Тип сервера: Database Engine
   - Ім'я сервера: [ім'я вашого комп'ютера]
   - Метод аутентифікації: Windows authentication
   - Шифрування: опціонально

## Перевірка роботи

### Тестування середовища:
1. Відкриття нового вікна запиту
2. Написання простого SQL-запиту:
   ```sql
   SELECT 5 + 5;
   ```
3. Виконання запиту для перевірки результату

### Додаткові налаштування:
- Можливість створення ярлика SSMS на робочому столі
- Налаштування швидкого доступу до середовища

*Примітка: Після успішного встановлення можна починати вивчення Structured Query Language (SQL) та його компонентів.*


# Microsoft SQL Server basics

# SQL SELECT: Основи роботи з запитами

## I. Підготовка середовища

### 1. Налаштування SQL Server Management Studio (SSMS):
- Запуск SSMS
- Підключення до бази даних:
  - Тип сервера: Database Engine
  - Аутентифікація: Windows
  - Налаштування відображення номерів рядків

### 2. Створення бази даних:
```sql
CREATE DATABASE Employee_Details;
USE Employee_Details;
```

## II. Робота з таблицями

### 1. Структура таблиці Employees:
- Employee ID
- First Name
- Last Name
- Department
- Salary
- Hire Date

## III. SELECT запити

### 1. Базовий SELECT:
```sql
SELECT * FROM Employees;
```
- Вибір усіх стовпців та рядків

### 2. Вибір окремих стовпців:
```sql
SELECT FirstName FROM Employees;
SELECT FirstName, Salary FROM Employees;
SELECT FirstName, LastName FROM Employees;
```

### 3. Об'єднання стовпців:
```sql
SELECT 
    EmployeeID,
    CONCAT(FirstName, ' ', LastName) FROM Employees;
```

### 4. Використання псевдонімів (alias):
```sql
SELECT 
    EmployeeID,
    CONCAT(FirstName, ' ', LastName) [Full Name] 
FROM Employees;

-- або

SELECT 
    EmployeeID,
    CONCAT(FirstName, ' ', LastName) AS [Full Name] 
FROM Employees;
```

## IV. Ключові особливості

### 1. Використання CONCAT:
- Об'єднання текстових полів
- Додавання пробілів між значеннями

### 2. Псевдоніми:
- Створення зрозумілих назв стовпців
- Використання ключового слова AS (опціонально)
- Використання квадратних дужок для назв з пробілами

### 3. IntelliSense:
- Автодоповнення назв стовпців
- Підказки при написанні запитів

## V. Практичні поради

### 1. Виконання запитів:
- Використання кнопки Execute
- Гаряча клавіша Ctrl+E
- Вибір конкретного запиту для виконання

### 2. Перегляд результатів:
- Кількість повернених рядків
- Час виконання запиту
- Повідомлення про успішність виконання

*Примітка: Всі приклади коду будуть доступні в ресурсах курсу для практики.*


# SQL DISTINCT: Робота з унікальними значеннями

## I. Підготовка до роботи

### 1. Створення тестової таблиці:
- Назва таблиці: Employee_Records
- Структура:
  - Employee ID
  - First Name
  - Last Name
  - Department
  - Salary

### 2. Базовий перегляд даних:
```sql
SELECT * FROM Employee_Records;
```

## II. Використання DISTINCT

### 1. Вибір унікальних імен:
```sql
SELECT DISTINCT FirstName 
FROM Employee_Records;
```
- Видалення дублікатів імен (наприклад, John, Jane)
- Відображення тільки унікальних значень

### 2. Комбінації унікальних значень:
```sql
SELECT DISTINCT FirstName, LastName 
FROM Employee_Records;
```
- Пошук унікальних комбінацій імен та прізвищ
- Приклади результатів:
  * Emily Davis
  * Jane Smith
  * John Miller
  * Michael Brown

### 3. Унікальні зарплати:
```sql
SELECT DISTINCT Salary 
FROM Employee_Records;
```
- Відображення унікальних значень зарплат
- Усунення повторюваних значень

## III. Особливості DISTINCT

### 1. Робота з усіма стовпцями:
```sql
SELECT DISTINCT * 
FROM Employee_Records;
```
- Пошук унікальних записів за всіма полями
- Врахування відмінностей у Employee ID

### 2. Важливі моменти:
- DISTINCT враховує всі вказані стовпці разом
- Запис вважається унікальним, якщо відрізняється хоча б одне значення
- При використанні * перевіряється унікальність усього запису

## IV. Практичні аспекти

### 1. Виконання запитів:
- Використання Ctrl+E для швидкого виконання
- Перевірка результатів запиту

### 2. Аналіз результатів:
- Порівняння кількості записів до і після DISTINCT
- Перевірка правильності фільтрації

*Примітка: Весь код доступний в ресурсах курсу для практики та подальшого вивчення.*




# Тимчасові таблиці в SQL Server

## І. Вступ до тимчасових таблиць

### 1. Типи існуючих таблиць у базі даних:
- DBO.Employees
- DBO.Employee_Records

## ІІ. Створення тимчасових таблиць

### 1. Тимчасова таблиця з одним #:
```sql
SELECT * INTO #temp1 
FROM dbo.Employees;
```
Особливості:
- Доступна тільки в поточному вікні запиту
- Видаляється після закриття сесії
- Не видима в інших вікнах запиту

### 2. Тимчасова таблиця з двома ##:
```sql
SELECT * INTO ##temp2 
FROM dbo.Employee_Records;
```
Особливості:
- Доступна у всіх вікнах запиту
- Видима в інших сесіях SQL Server
- Існує поки активна оригінальна сесія

## ІІІ. Практичне використання

### 1. Перевірка даних:
```sql
SELECT * FROM #temp1;
SELECT * FROM dbo.Employees;
```
- Порівняння даних оригінальної та тимчасової таблиць
- Перевірка ідентичності структури

### 2. Обмеження доступу:
- Таблиця #temp1:
  * Доступна лише в original query window
  * Помилка при спробі доступу з іншого вікна
- Таблиця ##temp2:
  * Доступна в усіх вікнах
  * Доступна в інших екземплярах SQL Server

## IV. Важливі особливості

### 1. Життєвий цикл:
- Одинарний #:
  * Існує тільки в межах сесії створення
  * Автоматично видаляється після закриття
- Подвійний ##:
  * Існує поки активна створююча сесія
  * Доступна між різними сесіями

### 2. Обмеження:
- Необхідність активної оригінальної сесії
- Автоматичне видалення при закритті сесії
- Різні рівні видимості залежно від типу

*Примітка: У наступних сесіях будуть розглянуті додаткові концепції та питання для інтерв'ю.*


# Використання WHERE в SQL: Фільтрація даних

## І. Основи WHERE

### 1. Базовий синтаксис:
```sql
SELECT * FROM Employee_Records 
WHERE умова;
```

### 2. Приклади фільтрації:
- За ID працівника:
```sql
SELECT * FROM Employee_Records 
WHERE EmployeeID = 2;
```
- За зарплатою:
```sql
SELECT * FROM Employee_Records 
WHERE Salary >= 75000;
```

## II. Комбінація з іншими операторами

### 1. Вибір конкретних стовпців:
```sql
SELECT EmployeeID, FirstName 
FROM Employee_Records 
WHERE EmployeeID = 2;
```

### 2. Використання з DISTINCT:
```sql
SELECT DISTINCT FirstName, LastName, Department, Salary 
FROM Employee_Records 
WHERE Salary < 75000;
```

## III. Оператори порівняння

### 1. Числові порівняння:
- Більше або дорівнює (>=)
- Менше (<)
- Дорівнює (=)

### 2. Приклади використання:
- Зарплата більше 75000:
```sql
SELECT * FROM Employee_Records 
WHERE Salary >= 75000;
```
- Зарплата менше 75000:
```sql
SELECT * FROM Employee_Records 
WHERE Salary < 75000;
```

## IV. Практичні особливості

### 1. Результати фільтрації:
- Відображаються тільки записи, що відповідають умові
- Можливість комбінування з іншими операторами

### 2. Особливості DISTINCT:
- Видалення дублікатів після фільтрації
- Порівняння всіх вибраних стовпців

## V. Корисні поради

### 1. Робота з IntelliSense:
- Автодоповнення назв стовпців
- Підказки при написанні умов

### 2. Перевірка результатів:
- Порівняння результатів з і без DISTINCT
- Перевірка правильності фільтрації

*Примітка: У наступних уроках буде розглянуто складніші запити з використанням WHERE та комбінування з іншими операторами SQL.*


# Використання ORDER BY в SQL: Сортування даних

## І. Підготовка до роботи

### 1. Налаштування середовища:
- Вибір бази даних Employee_Details
- Використання таблиці DBO.Employees
- Перегляд початкових даних

### 2. Базовий перегляд даних:
```sql
SELECT * FROM dbo.Employees;
```

## ІІ. Базове сортування

### 1. Сортування за зростанням:
```sql
SELECT * FROM dbo.Employees 
ORDER BY Salary;
```
- За замовчуванням сортує за зростанням
- Можна явно вказати ASC

### 2. Сортування за спаданням:
```sql
SELECT * FROM dbo.Employees 
ORDER BY Salary DESC;
```
- Використання ключового слова DESC
- Відображення від найбільшого до найменшого

## III. Багатоколонкове сортування

### 1. Комбіноване сортування:
```sql
SELECT * FROM dbo.Employees 
ORDER BY FirstName ASC, Salary DESC;
```
- Спочатку сортування за першим стовпцем
- Потім за другим стовпцем у межах першого

### 2. Приклади комбінацій:
- За відділом та зарплатою:
```sql
SELECT * FROM dbo.Employees 
ORDER BY Department ASC, Salary DESC;
```
Результат показує:
- Спочатку Finance (60,000)
- Потім HR (50,000)
- IT (75,000, 70,000)
- Marketing (55,000)

## IV. Практичні особливості

### 1. Правила сортування:
- ASC можна не вказувати (за замовчуванням)
- DESC потрібно вказувати явно
- Можливість комбінування різних напрямків сортування

### 2. Порядок виконання:
- Сортування виконується послідовно зліва направо
- Кожен наступний стовпець сортується в межах попереднього

*Примітка: ORDER BY - важливий інструмент для організації даних у зручному для аналізу форматі.*

#  Оператори ORDER BY, AND та OR в SQL

## ORDER BY: Додаткові особливості сортування

### Ключові моменти про ORDER BY:
- При сортуванні за зростанням (ASC) ключове слово ASC можна опустити
- При сортуванні за спаданням (DESC) ключове слово DESC обов'язкове
- Можливе сортування за кількома стовпцями одночасно

### Приклад:
```sql
SELECT * FROM employee_records 
ORDER BY department, salary DESC
```
Цей запит відсортує результати:
- Спочатку за департаментом (за зростанням)
- Потім за зарплатою (за спаданням)

## Оператори AND та OR

### Оператор AND
- Використовується для комбінування кількох умов
- Всі умови повинні бути істинними для отримання результату
- Синтаксис:
```sql
SELECT * FROM employee_records 
WHERE last_name = 'Miller' 
AND employee_id = 3
```

### Оператор OR
- Використовується коли достатньо виконання хоча б однієї умови
- Повертає результат, якщо істинна хоча б одна умова
- Приклад:
```sql
SELECT * FROM employee_records 
WHERE department = 'HR' 
OR department = 'Finance'
```

### Комбінування AND та OR
- Можна використовувати обидва оператори в одному запиті
- Важливо правильно групувати умови дужками
- Приклад:
```sql
SELECT * FROM employee_records 
WHERE (department = 'HR' OR department = 'Finance')
AND salary = 60000
```

## Важливі зауваження:
1. При роботі з текстовими значеннями використовуємо одинарні лапки
2. Для числових значень лапки не обов'язкові
3. При комбінуванні операторів важливо використовувати дужки для правильного групування умов
4. Оператор AND має вищий пріоритет ніж OR

## Практичні поради:
- Завжди перевіряйте результати запиту на тестових даних
- Використовуйте відступи та форматування для кращої читабельності запитів
- При складних умовах використовуйте дужки для явного визначення пріоритету операцій

# Оператори NOT, BETWEEN та IN в SQL

## Оператор NOT

### Базове використання NOT
- Використовується для заперечення умови
- Можна застосовувати до різних типів полів (текстових, числових)
- Синтаксис:
```sql
SELECT * FROM employee_records 
WHERE NOT first_name = 'John'
```

### Комбінування NOT з іншими операторами
```sql
SELECT * FROM employee_records 
WHERE NOT first_name = 'John' 
AND NOT salary = 60000
```

### Приклади використання:
- Фільтрація записів, де прізвище не 'Miller'
- Виключення записів з певного відділу
- Комбінування з OR: `WHERE NOT last_name = 'Miller' OR NOT department = 'HR'`

## Оператор BETWEEN

### Основне призначення
- Перевірка чи значення знаходиться в заданому діапазоні
- Включає граничні значення
- Можна використовувати з числами та датами

### Синтаксис:
```sql
SELECT * FROM employee_records 
WHERE salary BETWEEN 75000 AND 85000
```

### Альтернативний запис:
```sql
SELECT * FROM employee_records 
WHERE salary >= 75000 AND salary <= 85000
```

### NOT BETWEEN
- Використовується для значень поза діапазоном
- Два способи запису:
```sql
WHERE salary NOT BETWEEN 75000 AND 85000
WHERE NOT salary BETWEEN 75000 AND 85000
```

## Оператор IN

### Призначення
- Перевірка на входження в список значень
- Заміна multiple OR conditions
- Покращує читабельність коду

### Приклади використання:
```sql
-- Використання IN
SELECT * FROM employee_records 
WHERE department IN ('HR', 'IT')

-- Еквівалентний запис з OR
SELECT * FROM employee_records 
WHERE department = 'HR' OR department = 'IT'
```

### NOT IN
- Виключення значень зі списку
```sql
SELECT * FROM employee_records 
WHERE department NOT IN ('HR', 'IT')
```

## Важливі зауваження

### Регістр символів
- SQL Server нечутливий до регістру для:
  - Ключових слів (SELECT, WHERE, FROM)
  - Імен таблиць
  - Імен стовпців
  - Операторів (BETWEEN, IN, NOT)
- Можна використовувати як верхній, так і нижній регістр

### Практичні поради
1. Використовуйте IN замість множинних OR для кращої читабельності
2. При роботі з діапазонами BETWEEN часто зручніший ніж складні умови
3. Комбінуйте оператори для створення складних умов
4. Завжди перевіряйте результати на тестових даних

# Оператор INSERT INTO в SQL

## Основи INSERT INTO

### Базовий синтаксис
```sql
INSERT INTO dbo.employees (employee_id, first_name, last_name, department, salary, hire_date)
VALUES (6, 'Raj', 'Ambani', 'IT', 67000, '2023-04-20')
```

### Структура оператора:
1. `INSERT INTO` - ключові слова для початку вставки
2. Назва таблиці (наприклад, `dbo.employees`)
3. Список стовпців у дужках
4. Ключове слово `VALUES`
5. Значення у дужках у тому ж порядку, що й стовпці

## Способи вставки даних

### Повна вставка з указанням стовпців
- Вказуємо всі стовпці та їх значення
- Найбільш явний та зрозумілий спосіб
- Приклад:
```sql
INSERT INTO dbo.employees 
(employee_id, first_name, last_name, department, salary, hire_date)
VALUES (6, 'Raj', 'Ambani', 'IT', 67000, '2023-04-20')
```

### Часткова вставка
- Вказуємо лише потрібні стовпці
- Інші стовпці отримують NULL
- Приклад:
```sql
INSERT INTO dbo.employees 
(employee_id, first_name, last_name)
VALUES (7, 'Rohit', 'Meera')
```

### Вставка без указання стовпців
- Потрібно вказати значення для ВСІХ стовпців
- Значення мають бути в правильному порядку
- Приклад:
```sql
INSERT INTO dbo.employees
VALUES (8, 'Mahesh', 'Narang', 'HR', 73000, '2024-01-21')
```

## Важливі особливості

### Типи даних
- Числові значення вводяться без лапок
- Текстові значення в одинарних лапках
- Дати в одинарних лапках у форматі 'YYYY-MM-DD'

### Порядок стовпців
- Для визначення порядку стовпців можна використовувати запит:
```sql
SELECT * FROM information_schema.columns 
WHERE table_name = 'employees'
```
- Колонка `ordinal_position` показує порядок стовпців

### Практичні поради
1. Завжди вказуйте список стовпців для уникнення помилок
2. Перевіряйте типи даних перед вставкою
3. Використовуйте SELECT після INSERT для перевірки
4. При частковій вставці враховуйте NULL-значення

## Помилки, яких слід уникати
1. Невідповідність типів даних
2. Неправильний порядок значень
3. Пропуск обов'язкових полів
4. Неправильне форматування дат
5. Відсутність лапок для текстових даних

# Робота з NULL значеннями в SQL

## Що таке NULL?

### Визначення NULL
- NULL - це спеціальне значення, яке вказує на відсутність даних
- NULL з'являється, коли поле залишається порожнім при створенні запису
- NULL відрізняється від порожнього рядка ('') та нуля (0)

### Приклади різних типів порожніх значень:
```sql
-- Запис з NULL
INSERT INTO dbo.employees 
VALUES (7, 'Rohit', 'Meera', NULL, NULL, NULL);

-- Запис з порожнім рядком
INSERT INTO dbo.employees 
VALUES (9, 'J', '', 'IT', 73000, '2022-04-04');

-- Запис з нулем
INSERT INTO dbo.employees 
VALUES (10, 'Nathan', 'Nathan', '0', 54000, '2021-02-22');
```

## Робота з NULL в запитах

### Перевірка на NULL
- Не можна використовувати звичайні оператори порівняння (=, !=)
- Потрібно використовувати спеціальні оператори IS NULL та IS NOT NULL

### Правильний синтаксис:
```sql
-- Пошук записів з NULL
SELECT * FROM dbo.employees 
WHERE department IS NULL;

-- Пошук записів без NULL
SELECT * FROM dbo.employees 
WHERE department IS NOT NULL;
```

### Неправильний синтаксис:
```sql
-- Це НЕ працюватиме
SELECT * FROM dbo.employees 
WHERE department = NULL;
```

## Важливі особливості

### Відмінності між типами порожніх значень
1. NULL
   - Вказує на відсутність даних
   - Відображається як "NULL" в результатах
   - Потребує спеціальних операторів для порівняння

2. Порожній рядок ('')
   - Є фактичним значенням
   - Відображається як пустий простір
   - Можна порівнювати звичайними операторами

3. Нуль (0)
   - Є конкретним числовим значенням
   - Відображається як "0"
   - Можна використовувати в математичних операціях

### Практичні поради
1. Завжди використовуйте IS NULL замість = NULL
2. Пам'ятайте про різницю між NULL, порожнім рядком та нулем
3. При проектуванні бази даних вирішіть, чи дозволяти NULL значення
4. Використовуйте NULL для позначення відсутніх даних, а не порожні рядки

## Поширені помилки
1. Використання = NULL замість IS NULL
2. Плутанина між NULL та порожнім рядком
3. Спроба виконувати математичні операції з NULL
4. Неправильна обробка NULL у WHERE умовах

#  Оператор UPDATE в SQL

## Базові принципи UPDATE

### Синтаксис UPDATE
```sql
UPDATE назва_таблиці
SET колонка1 = значення1,
    колонка2 = значення2
WHERE умова;
```

### Важливі правила:
1. Завжди використовуйте WHERE умову
2. Перевірте дані SELECT-запитом перед оновленням
3. Спочатку тестуйте на тимчасовій таблиці

## Приклади використання UPDATE

### Оновлення одного стовпця
```sql
-- Заміна NULL значення на 'HR' в стовпці department
UPDATE employees
SET department = 'HR'
WHERE department IS NULL;
```

### Оновлення кількох стовпців
```sql
UPDATE employees
SET salary = 89000,
    hire_date = '2023-01-01'
WHERE employee_id = 7;
```

## Важливі застереження

### Небезпека відсутності WHERE
- Без WHERE умови оновляться ВСІ записи таблиці
- Приклад небезпечного запиту:
```sql
UPDATE employees
SET department = 'Finance'
-- Всі записи будуть змінені!
```

### Безпечні практики
1. Створення тимчасової таблиці для тестування:
```sql
SELECT * INTO #temp 
FROM employees;
```

2. Перевірка даних перед оновленням:
```sql
-- Спочатку перевірте дані
SELECT * FROM employees 
WHERE умова;

-- Потім оновіть
UPDATE employees
SET колонка = значення
WHERE та_сама_умова;
```

## Практичні поради

### Перед оновленням даних:
1. Створіть резервну копію або тимчасову таблицю
2. Перевірте кількість рядків, які будуть оновлені
3. Використовуйте транзакції для важливих оновлень
4. Завжди включайте WHERE умову

### При роботі з виробничою базою даних:
1. Двічі перевірте WHERE умову
2. Спочатку протестуйте на тестовій базі
3. Зробіть резервну копію перед великими змінами
4. Документуйте всі зміни

## Поширені помилки
1. Пропуск WHERE умови
2. Неправильне написання імен стовпців
3. Неправильні типи даних в SET частині
4. Занадто широкі умови в WHERE
5. Відсутність перевірки перед оновленням

# Оператори DELETE, DROP та TRUNCATE в SQL

## Оператор DELETE

### Синтаксис DELETE
```sql
DELETE FROM назва_таблиці
WHERE умова;
```

### Особливості DELETE:
1. Видаляє окремі записи за умовою WHERE
2. Без WHERE видалить усі записи
3. Структура таблиці залишається без змін

### Приклад використання:
```sql
-- Видалення записів за умовою
DELETE FROM employees
WHERE last_name = '' OR department = '0';
```

## Оператор TRUNCATE

### Синтаксис TRUNCATE
```sql
TRUNCATE TABLE назва_таблиці;
```

### Особливості TRUNCATE:
1. Видаляє ВСІ записи з таблиці
2. Структура таблиці залишається
3. Працює швидше ніж DELETE без WHERE
4. Не можна використовувати WHERE

## Оператор DROP

### Синтаксис DROP
```sql
DROP TABLE назва_таблиці;
```

### Особливості DROP:
1. Видаляє всю таблицю повністю
2. Видаляє структуру таблиці
3. Після DROP таблиця перестає існувати
4. Не можна відновити дані простим INSERT

## Порівняння операторів

### DELETE
- Видаляє обрані записи
- Можна використовувати WHERE
- Зберігає структуру таблиці
- Можна відмінити (ROLLBACK)
- Повільніший для видалення всіх даних

### TRUNCATE
- Видаляє всі записи
- Не можна використовувати WHERE
- Зберігає структуру таблиці
- Не можна відмінити (ROLLBACK)
- Швидший за DELETE

### DROP
- Видаляє всю таблицю
- Видаляє структуру таблиці
- Не можна відмінити
- Потребує повторного створення таблиці

## Важливі практичні поради

### Безпечне використання:
1. Завжди використовуйте WHERE з DELETE
2. Робіть резервну копію перед TRUNCATE або DROP
3. Перевіряйте умови DELETE перед виконанням
4. Використовуйте тимчасові таблиці для тестування

### Типові помилки:
1. Забування WHERE в DELETE
2. Використання DROP замість TRUNCATE
3. Невірні умови в WHERE
4. Відсутність резервної копії

## Важливо для співбесід
- Розуміння різниці між операторами
- Знання особливостей кожного оператора
- Вміння пояснити випадки використання
- Розуміння впливу на продуктивність

# Коментарі та вибірка TOP записів в SQL

## Коментарі в SQL

### Однорядкові коментарі
- Починаються з двох дефісів (--)
- Діють до кінця рядка
- Приклад:
```sql
-- Це однорядковий коментар
SELECT * FROM employees;
```

### Багаторядкові коментарі
- Починаються з /* та закінчуються */
- Можуть охоплювати кілька рядків
- Приклад:
```sql
/* Це багаторядковий коментар
   Він може займати кілька рядків
   І допомагає пояснити код */
SELECT * FROM employees;
```

### Використання коментарів
- Покращують читабельність коду
- Пояснюють логіку запитів
- Допомагають іншим розробникам
- Можна тимчасово вимкнути частину коду

## Оператор TOP

### Базовий синтаксис
```sql
SELECT TOP n columns
FROM table_name;
```

### Варіанти використання TOP

1. Вибірка всіх стовпців:
```sql
SELECT TOP 2 *
FROM employees;
```

2. Вибірка конкретних стовпців:
```sql
SELECT TOP 4 first_name, last_name
FROM employees;
```

3. Вибірка з умовами:
```sql
SELECT TOP 3 employee_id, salary
FROM employees
WHERE department = 'IT';
```

### Особливості TOP
1. Повертає вказану кількість записів
2. Можна використовувати з будь-якими стовпцями
3. Працює з іншими операторами SQL
4. Корисний для обмеження розміру результату

## Практичні поради

### Коментарі
1. Використовуйте коментарі для документації коду
2. Пишіть зрозумілі та інформативні коментарі
3. Регулярно оновлюйте коментарі при зміні коду
4. Не зловживайте очевидними коментарями

### TOP
1. Використовуйте для обмеження великих наборів даних
2. Комбінуйте з ORDER BY для отримання конкретних записів
3. Враховуйте продуктивність при великих значеннях n
4. Перевіряйте результати на тестових даних

## Поширені помилки
1. Надмірне коментування очевидного коду
2. Застарілі коментарі, що не відповідають коду
3. Використання TOP без ORDER BY, коли порядок важливий
4. Неврахування впливу TOP на продуктивність запиту


#  Агрегатні функції SQL - MAX та GROUP BY

## Функція MAX

### Основи використання MAX
- Знаходить максимальне значення в стовпці
- Працює з різними типами даних
- Ігнорує NULL значення
- Можна використовувати псевдоніми для результатів

### Приклади використання MAX:

1. З числовими даними:
```sql
SELECT MAX(total_amount) AS [Maximum Amount]
FROM dbo.sales;
```

2. З датами:
```sql
SELECT MAX(sale_date) AS [Max Sale Date]
FROM dbo.sales;
```

3. З текстовими даними:
```sql
SELECT MAX(payment_method) AS [Max Payment Method]
FROM dbo.sales;
```

## Оператор GROUP BY

### Призначення GROUP BY
- Групує дані за вказаними стовпцями 
- Дозволяє застосовувати агрегатні функції до груп
- Обов'язковий при комбінуванні агрегатних і неагрегатних стовпців

### Правила використання:
1. Всі неагреговані стовпці в SELECT повинні бути в GROUP BY
2. GROUP BY пишеться після WHERE, але перед ORDER BY
3. Можна групувати за кількома стовпцями

### Приклади GROUP BY:

1. Максимальна кількість за продуктами:
```sql
SELECT product_id,
       MAX(quantity) AS [Maximum Quantity]
FROM dbo.sales
GROUP BY product_id;
```

2. Максимальна сума продажів за датами:
```sql
SELECT sale_date,
       MAX(total_amount) AS [Maximum Total Amount]
FROM dbo.sales
GROUP BY sale_date;
```

## Важливі особливості

### Робота з NULL значеннями
- MAX ігнорує NULL при обчисленнях
- NULL не впливає на результат
- При групуванні NULL утворює окрему групу

### Використання псевдонімів
- Рекомендується давати зрозумілі назви результатам
- Використовуйте квадратні дужки для назв з пробілами
- Псевдоніми покращують читабельність результатів

## Практичні поради

### При використанні MAX:
1. Перевіряйте тип даних стовпця
2. Враховуйте наявність NULL значень
3. Використовуйте зрозумілі псевдоніми
4. Перевіряйте результати на тестових даних

### При використанні GROUP BY:
1. Перевіряйте всі неагреговані стовпці
2. Плануйте групування заздалегідь
3. Використовуйте HAVING для фільтрації груп
4. Перевіряйте кількість отриманих груп



# Функція MIN в SQL

## Основи функції MIN

### Загальний синтаксис
```sql
SELECT MIN(column_name) AS [Alias]
FROM table_name;
```

### Використання з різними типами даних

1. Числові дані:
```sql
SELECT MIN(quantity) AS [Minimum Quantity]
FROM dbo.sales;
```

2. Дати:
```sql
SELECT MIN(sale_date) AS [Minimum Sale Date]
FROM dbo.sales;
```

3. Текстові дані:
```sql
SELECT MIN(payment_method) AS [Minimum Payment Method]
FROM dbo.sales;
```

## Особливості роботи MIN

### Обробка NULL значень
- MIN ігнорує NULL значення
- NULL не враховуються при пошуку мінімуму
- Результат повертається на основі непорожніх значень

### Псевдоніми (Аліаси)
- Рекомендується використовувати для зрозумілих назв
- Записуються в квадратних дужках `[Назва]`
- Покращують читабельність результатів

## MIN з GROUP BY

### Синтаксис
```sql
SELECT column_name,
       MIN(aggregated_column) AS [Alias]
FROM table_name
GROUP BY column_name;
```

### Приклад використання
```sql
SELECT store_id,
       MIN(total_amount) AS [Minimum Total Amount]
FROM dbo.sales
GROUP BY store_id;
```

### Правила групування
1. Неагреговані стовпці в SELECT повинні бути в GROUP BY
2. Агреговані стовпці (з MIN) не потребують GROUP BY
3. GROUP BY може містити кілька стовпців

## Практичні приклади

### Мінімальна сума продажів за магазинами
```sql
SELECT store_id,
       MIN(total_amount) AS [Minimum Total Amount]
FROM dbo.sales
GROUP BY store_id;
```

### Результат покаже:
- Мінімальну суму продажів для кожного магазину
- Усі унікальні store_id
- Згруповані результати за магазинами

## Важливі моменти

### При використанні MIN:
1. Перевіряйте тип даних стовпця
2. Враховуйте наявність NULL значень
3. Використовуйте зрозумілі псевдоніми
4. Перевіряйте результати на тестових даних

### При використанні з GROUP BY:
1. Правильно визначайте стовпці для групування
2. Перевіряйте всі неагреговані стовпці
3. Використовуйте HAVING для фільтрації груп
4. Перевіряйте очікувану кількість груп


# Агрегатні функції SQL - SUM, AVG та COUNT

## Функція SUM

### Призначення та синтаксис
```sql
SELECT SUM(column_name) AS [Alias]
FROM table_name;
```

### Приклади використання
```sql
-- Сума одного стовпця
SELECT SUM(quantity) AS [Total Quantity]
FROM dbo.sales;

-- Сума кількох стовпців
SELECT SUM(quantity) AS [Total Quantity],
       SUM(total_amount) AS [Sum of Amount]
FROM dbo.sales;
```

## Функція AVG (AVERAGE)

### Базовий синтаксис
```sql
SELECT AVG(column_name) AS [Alias]
FROM table_name;
```

### Приклади використання
```sql
-- Середнє значення для одного стовпця
SELECT AVG(quantity) AS [Average Quantity]
FROM dbo.sales;

-- Середнє для кількох стовпців
SELECT AVG(quantity) AS [Avg Quantity],
       AVG(total_amount) AS [Avg Amount]
FROM dbo.sales;
```

## Функція COUNT

### Варіанти синтаксису
```sql
-- Підрахунок всіх рядків
SELECT COUNT(*) AS [Number of Rows]
FROM table_name;

-- Підрахунок значень у стовпці (без NULL)
SELECT COUNT(column_name) AS [Count]
FROM table_name;

-- Підрахунок унікальних значень
SELECT COUNT(DISTINCT column_name) AS [Distinct Count]
FROM table_name;
```

### Особливості COUNT
1. COUNT(*) враховує всі рядки, включаючи NULL
2. COUNT(column) ігнорує NULL значення
3. COUNT(DISTINCT) рахує унікальні значення

## Використання з GROUP BY

### Загальний синтаксис
```sql
SELECT column_name,
       SUM(value_column) AS [Total],
       AVG(value_column) AS [Average],
       COUNT(*) AS [Count]
FROM table_name
GROUP BY column_name;
```

### Правила групування
1. Неагреговані стовпці в SELECT повинні бути в GROUP BY
2. Можна групувати за кількома стовпцями
3. Агреговані стовпці не потребують GROUP BY

## Особливості роботи з NULL

### Для всіх агрегатних функцій:
1. SUM ігнорує NULL значення
2. AVG ігнорує NULL при обчисленні середнього
3. COUNT(*) включає рядки з NULL
4. COUNT(column) ігнорує NULL
5. COUNT(DISTINCT) не враховує NULL як окреме значення

## Практичні приклади

### Комбінування функцій з GROUP BY
```sql
SELECT product_id,
       store_id,
       SUM(quantity) AS [Total Quantity],
       AVG(total_amount) AS [Average Amount],
       COUNT(*) AS [Number of Sales]
FROM dbo.sales
GROUP BY product_id, store_id;
```

## Поради щодо використання

### При роботі з агрегатними функціями:
1. Завжди використовуйте інформативні aliases
2. Перевіряйте наявність NULL значень
3. Вибирайте правильний тип COUNT
4. Переконайтеся, що GROUP BY включає всі необхідні стовпці

# Оператор GROUP BY в SQL

## Приклад таблиці продажів

### Структура таблиці dbo.sales:
- category (категорія)
- subcategory (підкатегорія)
- date (дата)
- sales (продажі в USD)

### Приклад даних:
```sql
category    subcategory    date        sales
----------- ------------- ----------   ------
fruits      apples        2024-01-01   10
fruits      apples        2024-01-02   20
fruits      grapes        2024-01-01   10
fruits      grapes        2024-01-02   20
vegetables  onion         2024-01-01   30
vegetables  potato        2024-01-01   10
vegetables  onion         2024-01-02   20
```

## Використання GROUP BY

### Групування за однією колонкою
```sql
SELECT category,
       SUM(sales) AS [total_sales]
FROM dbo.sales
GROUP BY category;
```

#### Результат:
```
category    total_sales
----------- -----------
fruits      60
vegetables  60
```

### Групування за кількома колонками
```sql
SELECT category,
       subcategory,
       SUM(sales) AS [total_sales]
FROM dbo.sales
GROUP BY category, subcategory;
```

#### Результат:
```
category    subcategory    total_sales
----------- ------------- -----------
fruits      apples        30
fruits      grapes        30
vegetables  onion         50
vegetables  potato        10
```

## Важливі правила GROUP BY

1. **Правило вибору стовпців:**
   - Усі стовпці в SELECT, які не є агрегатними функціями, повинні бути в GROUP BY
   - Агрегатні функції (SUM, COUNT, AVG тощо) не потребують включення в GROUP BY

2. **Порядок операцій:**
   ```sql
   SELECT    -- 3
   FROM      -- 1
   WHERE     -- 2
   GROUP BY  -- 4
   HAVING    -- 5
   ORDER BY  -- 6
   ```

3. **Приклад повного запиту:**
   ```sql
   SELECT category,
          subcategory,
          SUM(sales) AS [total_sales]
   FROM dbo.sales
   WHERE sales > 0
   GROUP BY category, subcategory
   HAVING SUM(sales) > 20
   ORDER BY total_sales DESC;
   ```

## Практичні поради

### При використанні GROUP BY:
1. Перевіряйте всі неагреговані стовпці
2. Використовуйте алиаси для кращої читабельності
3. Комбінуйте з іншими агрегатними функціями
4. Перевіряйте результати на тестових даних

### Поширені помилки:
1. Пропуск стовпців у GROUP BY
2. Неправильний порядок операцій
3. Неправильне використання агрегатних функцій
4. Забування про фільтрацію даних


#  Практичне використання GROUP BY в SQL

## Приклад 1: Групування за методом оплати

### Базовий запит:
```sql
SELECT payment_method,
       SUM(total_amount) AS [sum_of_sales]
FROM dbo.sales
GROUP BY payment_method;
```

### Результат:
```
payment_method    sum_of_sales
---------------  ------------
NULL             390
cash             xxx
credit_card      xxx
debit_card       xxx
```

### Пояснення:
- Групуємо дані за методом оплати
- Обчислюємо суму продажів для кожного методу
- NULL значення формують окрему групу

## Приклад 2: Групування за кількома полями

### Запит з групуванням за product_id та payment_method:
```sql
SELECT product_id,
       payment_method,
       SUM(total_amount) AS [sum_of_sales]
FROM dbo.sales
GROUP BY product_id, payment_method
ORDER BY product_id;
```

### Особливості запиту:
1. Групування за двома полями
2. Додано сортування за product_id
3. Сума обчислюється для кожної унікальної комбінації

## Важливі аспекти при використанні GROUP BY

### Правила включення полів:
1. Всі неагреговані поля в SELECT повинні бути в GROUP BY
2. Поля з агрегатними функціями (SUM, COUNT, тощо) не включаються в GROUP BY
3. ORDER BY можна застосовувати після GROUP BY

### Порядок виконання:
1. FROM
2. GROUP BY
3. Агрегатні функції
4. SELECT
5. ORDER BY

## Практичні поради

### При написанні запитів:
1. Спочатку напишіть базовий SELECT для перевірки даних
2. Визначте поля для групування
3. Додайте необхідні агрегатні функції
4. Перевірте всі неагреговані поля в GROUP BY
5. За потреби додайте сортування

### Рекомендації щодо оптимізації:
1. Використовуйте індекси для полів групування
2. Обмежуйте кількість груп
3. Застосовуйте фільтрацію перед групуванням
4. Перевіряйте продуктивність на великих наборах даних

## Типові помилки та їх уникнення

### Поширені помилки:
1. Пропуск полів у GROUP BY
2. Неправильний порядок операцій
3. Надмірне групування
4. Відсутність перевірки результатів

### Як уникнути помилок:
1. Перевіряйте всі поля в SELECT
2. Тестуйте на малих наборах даних
3. Використовуйте коментарі для складних запитів
4. Завжди перевіряйте результати агрегації


# Оператор HAVING в SQL

## Основний приклад використання

### Базовий запит з GROUP BY та HAVING:
```sql
SELECT product_id,
       SUM(total_amount) AS [sum_of_sales],
       SUM(quantity) AS [total_quantity],
       AVG(total_amount) AS [avg_amount],
       AVG(quantity) AS [average_quantity]
FROM dbo.sales
GROUP BY product_id
HAVING SUM(total_amount) < 700;
```

## Відмінності між WHERE та HAVING

### WHERE:
- Фільтрує рядки до групування
- Працює з окремими рядками
- Не може використовувати агрегатні функції
- Виконується перед GROUP BY

### HAVING:
- Фільтрує результати після групування
- Працює з групами рядків
- Може використовувати агрегатні функції
- Виконується після GROUP BY

## Приклади використання HAVING

### 1. Фільтрація за сумою продажів:
```sql
SELECT product_id,
       SUM(total_amount) AS [sum_of_sales]
FROM dbo.sales
GROUP BY product_id
HAVING SUM(total_amount) < 700;
```

### 2. Множинні умови в HAVING:
```sql
SELECT product_id,
       SUM(total_amount) AS [sum_of_sales],
       SUM(quantity) AS [total_quantity]
FROM dbo.sales
GROUP BY product_id
HAVING SUM(total_amount) < 700 
   AND SUM(quantity) = 21;
```

## Порядок виконання запиту

1. FROM: вибір таблиці
2. WHERE: фільтрація рядків
3. GROUP BY: групування даних
4. HAVING: фільтрація груп
5. SELECT: вибір стовпців
6. ORDER BY: сортування результатів

## Практичні поради

### При використанні HAVING:
1. Використовуйте для фільтрації агрегованих даних
2. Перевіряйте умови на агрегатних функціях
3. Комбінуйте з GROUP BY
4. Уникайте надмірної фільтрації

### Типові сценарії використання:
1. Фільтрація груп за сумою
2. Фільтрація за середніми значеннями
3. Фільтрація за кількістю елементів у групі
4. Комбінація кількох умов

## Поширені помилки

### Чого слід уникати:
1. Використання HAVING замість WHERE для фільтрації окремих рядків
2. Забування GROUP BY при використанні HAVING
3. Неправильний порядок клаузул
4. Надмірне ускладнення умов у HAVING

### Оптимізація запитів:
1. Спочатку фільтруйте дані через WHERE
2. Потім групуйте через GROUP BY
3. В кінці застосовуйте HAVING
4. Перевіряйте продуктивність на великих наборах даних

#  Порівняння WHERE та HAVING в SQL

## Базові приклади використання

### Фільтрація з WHERE:
```sql
SELECT *
FROM dbo.sales
WHERE total_amount >= 161;
```

### Фільтрація з HAVING:
```sql
SELECT product_id,
       SUM(total_amount) AS [sum_of_sales]
FROM dbo.sales
GROUP BY product_id
HAVING SUM(total_amount) < 700;
```

## Ключові відмінності

### WHERE:
1. Фільтрує початкові дані до групування
2. Працює з окремими рядками
3. Не може використовувати агрегатні функції
4. Виконується до GROUP BY

### HAVING:
1. Фільтрує результати після групування
2. Працює з групами даних
3. Може використовувати агрегатні функції
4. Виконується після GROUP BY

## Комбінування WHERE та HAVING

### Приклад повного запиту:
```sql
SELECT product_id,
       SUM(total_amount) AS [sum_of_sales]
FROM dbo.sales
WHERE total_amount >= 161
GROUP BY product_id
HAVING SUM(total_amount) >= 250
ORDER BY product_id DESC;
```

### Порядок виконання:
1. FROM: вибір таблиці
2. WHERE: фільтрація рядків
3. GROUP BY: групування даних
4. HAVING: фільтрація груп
5. SELECT: вибір стовпців
6. ORDER BY: сортування результатів

## Практичні сценарії використання

### Коли використовувати WHERE:
1. Фільтрація окремих рядків
2. Прості умови порівняння
3. Фільтрація до агрегації
4. Умови на неагрегованих даних

### Коли використовувати HAVING:
1. Фільтрація згрупованих даних
2. Умови з агрегатними функціями
3. Фільтрація після групування
4. Складні умови на агрегованих даних

## Додаткові можливості

### Сортування результатів:
```sql
-- За спаданням
ORDER BY product_id DESC

-- За зростанням
ORDER BY sum_of_sales ASC
```

### Множинні умови:
```sql
WHERE total_amount >= 161
  AND quantity > 0
  
HAVING SUM(total_amount) >= 250
   AND COUNT(*) > 1
```

## Поради для співбесід

### Ключові моменти для пояснення:
1. Чітке розуміння різниці між WHERE та HAVING
2. Вміння пояснити порядок виконання запиту
3. Знання практичних сценаріїв використання
4. Розуміння оптимізації запитів

### Типові питання:
1. Коли краще використовувати WHERE, а коли HAVING?
2. Як комбінувати WHERE та HAVING в одному запиті?
3. Чому не можна використовувати агрегатні функції в WHERE?
4. Як впливає порядок WHERE та HAVING на продуктивність?

# INNER JOIN в SQL

## Основи з'єднання таблиць

### Приклад таблиць:
```sql
-- Таблиця 1 (table1)
C1    C2
--    --
1     a
1     b
2     c
NULL  d
3     e
7     f

-- Таблиця 2 (table2)
C1    C3
--    --
1     xa
2     mb
2     nx
NULL  m0
4     xy
5     tf
```

## Синтаксис INNER JOIN

### Базовий синтаксис:
```sql
SELECT *
FROM table1
INNER JOIN table2
ON table1.C1 = table2.C1;
```

### З використанням псевдонімів:
```sql
SELECT a.C1, a.C2, b.C3
FROM table1 a
INNER JOIN table2 b
ON a.C1 = b.C1;
```

## Правила INNER JOIN

### Основні принципи:
1. З'єднує рядки, де значення співпадають в обох таблицях
2. Пропускає NULL значення
3. Пропускає рядки без відповідності
4. Може створювати кілька результуючих рядків при множинних співпадіннях

### Результат з'єднання:
```sql
C1    C2    C1    C3
--    --    --    --
1     a     1     xa
1     b     1     xa
2     c     2     mb
2     c     2     nx
```

## Особливості роботи з NULL

### Важливі моменти:
1. NULL значення не створюють співпадінь
2. Рядки з NULL пропускаються
3. Потрібно використовувати OUTER JOIN для включення NULL

## Вибір стовпців

### Варіанти вибору:
1. SELECT * - всі стовпці з обох таблиць
2. Вибір конкретних стовпців
3. Використання псевдонімів таблиць
4. Уникнення дублювання стовпців

### Приклад оптимізованого запиту:
```sql
SELECT 
    a.C1,   -- Вибираємо C1 тільки з першої таблиці
    a.C2,   -- Стовпець з першої таблиці
    b.C3    -- Стовпець з другої таблиці
FROM table1 a
INNER JOIN table2 b
ON a.C1 = b.C1;
```

## Практичні поради

### При написанні запитів:
1. Використовуйте змістовні псевдоніми таблиць
2. Вказуйте явно потрібні стовпці замість *
3. Перевіряйте умови з'єднання
4. Враховуйте можливість NULL значень

### Оптимізація:
1. Використовуйте індекси для стовпців з'єднання
2. Обмежуйте кількість рядків де можливо
3. Уникайте з'єднань за необов'язковими стовпцями
4. Перевіряйте план виконання запиту


#  Практичне використання INNER JOIN в SQL Server

## Створення тестових таблиць

### Таблиця 1 (table1):
```sql
CREATE TABLE table1 (
    C1 INT,
    C2 VARCHAR(10)
);

INSERT INTO table1 VALUES
(1, 'a'),
(1, 'b'),
(2, 'c'),
(NULL, 'd'),
(3, 'e'),
(7, 'f');
```

### Таблиця 2 (table2):
```sql
CREATE TABLE table2 (
    C1 INT,
    C3 VARCHAR(10)
);

INSERT INTO table2 VALUES
(1, 'xa'),
(2, 'mb'),
(2, 'nx'),
(NULL, 'm0'),
(4, 'xy'),
(5, 'tf');
```

## Варіанти написання INNER JOIN

### Базовий синтаксис:
```sql
SELECT *
FROM table1
INNER JOIN table2
ON table1.C1 = table2.C1;
```

### Спрощений синтаксис (без слова INNER):
```sql
SELECT *
FROM table1
JOIN table2
ON table1.C1 = table2.C1;
```

### З використанням псевдонімів:
```sql
SELECT a.C1, a.C2, b.C3
FROM table1 a
JOIN table2 b
ON a.C1 = b.C1;
```

## Вибір стовпців у результаті

### Всі стовпці (*):
- Показує всі стовпці з обох таблиць
- Дублює стовпці зі співпадаючими іменами
- Не рекомендується для production-коду

### Вибіркові стовпці:
```sql
SELECT 
    table1.C1,  -- тільки C1 з першої таблиці
    table1.C2,  -- C2 з першої таблиці
    table2.C3   -- C3 з другої таблиці
FROM table1
JOIN table2
ON table1.C1 = table2.C1;
```

## Використання псевдонімів

### Переваги псевдонімів:
1. Скорочений код
2. Краща читабельність
3. Уникнення конфліктів імен
4. Спрощене обслуговування коду

### Приклад з псевдонімами:
```sql
SELECT 
    a.C1,
    a.C2,
    b.C3
FROM table1 a
JOIN table2 b
ON a.C1 = b.C1;
```

## Особливості роботи з даними

### Правила з'єднання:
1. Співпадіння значень створює рядок у результаті
2. NULL значення ігноруються
3. Відсутні значення не створюють рядків
4. Множинні співпадіння створюють декілька рядків

### Результат для наших таблиць:
```
C1    C2    C3
--    --    --
1     a     xa
1     b     xa
2     c     mb
2     c     nx
```

## Практичні поради

### При написанні запитів:
1. Використовуйте змістовні псевдоніми
2. Вказуйте конкретні стовпці замість *
3. Перевіряйте умови з'єднання
4. Враховуйте можливі NULL значення

### Оптимізація:
1. Використовуйте індекси для стовпців з'єднання
2. Обмежуйте кількість рядків де можливо
3. Вибирайте тільки необхідні стовпці
4. Використовуйте відповідні типи даних

#  LEFT JOIN в SQL

## Основи LEFT JOIN

### Синтаксис:
```sql
SELECT *
FROM table1
LEFT JOIN table2
ON table1.C1 = table2.C1;
```

### Альтернативний запис:
```sql
SELECT *
FROM table1
LEFT OUTER JOIN table2
ON table1.C1 = table2.C1;
```

## Принцип роботи LEFT JOIN

### Основні правила:
1. Включає ВСІ рядки з лівої таблиці
2. Додає відповідні рядки з правої таблиці
3. Якщо відповідності немає, додає NULL
4. Ігнорує NULL при порівнянні значень

### Приклад таблиць:
```sql
-- Таблиця 1 (Ліва)
C1    C2
--    --
1     a
1     b
2     c
NULL  d
3     e
7     f

-- Таблиця 2 (Права)
C1    C3
--    --
1     xa
2     mb
2     nx
NULL  m0
4     xy
5     tf
```

## Результат LEFT JOIN

### Повний результат (SELECT *):
```
C1    C2    C1    C3
--    --    --    --
1     a     1     xa
1     b     1     xa
2     c     2     mb
2     c     2     nx
NULL  d     NULL  NULL
3     e     NULL  NULL
7     f     NULL  NULL
```

### Пояснення результатів:
1. Співпадіння (1,1):
   - Створює два рядки через множинне співпадіння
   - Включає всі значення з обох таблиць

2. Співпадіння (2,2):
   - Також створює два рядки
   - Комбінує з обома відповідними записами

3. NULL значення:
   - NULL з лівої таблиці включається
   - Доповнюється NULL значеннями з правої таблиці
   
4. Відсутні співпадіння (3,7):
   - Записи з лівої таблиці зберігаються
   - Доповнюються NULL з правої таблиці

## Вибіркове відображення стовпців

### З використанням псевдонімів:
```sql
SELECT 
    a.C1,
    a.C2,
    b.C3
FROM table1 a
LEFT JOIN table2 b
ON a.C1 = b.C1;
```

### Переваги такого підходу:
1. Чіткий вибір потрібних стовпців
2. Уникнення дублювання стовпців
3. Кращий контроль над результатом
4. Більш ефективне використання ресурсів

## Практичні поради

### При використанні LEFT JOIN:
1. Правильно визначайте "ліву" таблицю
2. Враховуйте NULL значення
3. Використовуйте псевдоніми таблиць
4. Вибирайте тільки необхідні стовпці

# Практичне використання LEFT JOIN в SQL Server

## Підготовка даних

### Перегляд вихідних таблиць:
```sql
-- Перегляд даних в обох таблицях
SELECT * FROM table1;
SELECT * FROM table2;
```

## Варіанти написання LEFT JOIN

### Базовий синтаксис:
```sql
SELECT *
FROM table1
LEFT JOIN table2
ON table1.C1 = table2.C1;
```

### Альтернативний синтаксис:
```sql
SELECT *
FROM table1
LEFT OUTER JOIN table2
ON table1.C1 = table2.C1;
```

## Аналіз результатів

### Повний результат (всі стовпці):
```
C1    C2    C1    C3
--    --    --    --
1     a     1     xa    -- Співпадіння значень
1     b     1     xa    -- Множинне співпадіння
2     c     2     mb    -- Співпадіння значень
2     c     2     nx    -- Множинне співпадіння
NULL  d     NULL  NULL  -- NULL з лівої таблиці
3     e     NULL  NULL  -- Відсутнє співпадіння
7     f     NULL  NULL  -- Відсутнє співпадіння
```

### Пояснення кожного рядка:
1. **Прості співпадіння (1,1)**:
   - Значення співпадають
   - Включаються дані з обох таблиць

2. **Множинні співпадіння (2,2)**:
   - Створюється окремий рядок для кожного співпадіння
   - Дані з лівої таблиці дублюються

3. **NULL значення**:
   - NULL з лівої таблиці зберігається
   - Праві стовпці заповнюються NULL

4. **Відсутні співпадіння (3,7)**:
   - Рядки з лівої таблиці зберігаються
   - Праві стовпці заповнюються NULL

## Використання псевдонімів

### З вибором всіх стовпців:
```sql
SELECT *
FROM table1 a
LEFT JOIN table2 b
ON a.C1 = b.C1;
```

### З вибором конкретних стовпців:
```sql
SELECT 
    a.C1,
    a.C2,
    b.C3
FROM table1 a
LEFT JOIN table2 b
ON a.C1 = b.C1;
```

## Практичні поради

### При написанні запитів:
1. Використовуйте зрозумілі псевдоніми таблиць
2. Явно вказуйте потрібні стовпці замість *
3. Перевіряйте результати на тестових даних
4. Враховуйте особливості обробки NULL

### Оптимізація:
1. Вибирайте тільки необхідні стовпці
2. Використовуйте індекси для стовпців з'єднання
3. Слідкуйте за порядком таблиць (ліва/права)
4. Перевіряйте план виконання запиту

#  RIGHT JOIN в SQL

## Синтаксис RIGHT JOIN

### Базовий варіант:
```sql
SELECT *
FROM table1
RIGHT JOIN table2
ON table1.C1 = table2.C1;
```

### Альтернативний запис:
```sql
SELECT *
FROM table1
RIGHT OUTER JOIN table2
ON table1.C1 = table2.C1;
```

## Принцип роботи RIGHT JOIN

### Основні правила:
1. Включає ВСІ рядки з правої таблиці
2. Додає відповідні рядки з лівої таблиці
3. Якщо відповідності немає, додає NULL для лівої таблиці
4. NULL значення при порівнянні не співпадають

## Приклад результатів

### Повний результат (SELECT *):
```
C1    C2    C1    C3
--    --    --    --
1     a     1     xa     -- Співпадіння
1     b     1     xa     -- Множинне співпадіння
2     c     2     mb     -- Співпадіння
2     c     2     nx     -- Множинне співпадіння
NULL  NULL  NULL  m0     -- NULL з правої таблиці
NULL  NULL  4     xy     -- Відсутнє співпадіння
NULL  NULL  5     tf     -- Відсутнє співпадіння
```

### Аналіз результатів:
1. Прості співпадіння:
   - Значення 1 співпадає → включаються дані з обох таблиць
   - Значення 2 співпадає → включаються дані з обох таблиць

2. Множинні співпадіння:
   - Створюється окремий рядок для кожного співпадіння
   - Дані з правої таблиці можуть повторюватися

3. NULL та відсутні значення:
   - NULL з правої таблиці включається
   - Значення 4 і 5 включаються, бо вони в правій таблиці

## Вибіркове відображення стовпців

### З використанням псевдонімів:
```sql
SELECT 
    a.C1,
    a.C2,
    b.C3
FROM table1 a
RIGHT JOIN table2 b
ON a.C1 = b.C1;
```

### Переваги:
1. Чіткий контроль над вихідними даними
2. Уникнення дублювання стовпців
3. Кращий контроль над результатом
4. Оптимізація використання ресурсів

## Практичні поради

### При використанні RIGHT JOIN:
1. Правильно визначайте порядок таблиць
2. Враховуйте NULL значення
3. Використовуйте псевдоніми таблиць
4. Вибирайте тільки необхідні стовпці

### Оптимізація:
1. Використовуйте індекси для стовпців з'єднання
2. Обмежуйте кількість рядків де можливо
3. Вибирайте відповідний тип з'єднання
4. Перевіряйте план виконання запиту



#  Практичне використання RIGHT JOIN в SQL Server

## Підготовка даних

### Перегляд вихідних таблиць:
```sql
-- Перегляд даних
SELECT * FROM table1;
SELECT * FROM table2;
```

## Варіанти написання RIGHT JOIN

### Базовий синтаксис:
```sql
SELECT *
FROM table1
RIGHT JOIN table2
ON table1.C1 = table2.C1;
```

### З використанням OUTER:
```sql
SELECT *
FROM table1
RIGHT OUTER JOIN table2
ON table1.C1 = table2.C1;
```

## Детальний аналіз результатів

### Приклад з усіма стовпцями:
```
C1    C2    C1    C3
--    --    --    --
1     a     1     xa    -- Перше співпадіння
1     b     1     xa    -- Множинне співпадіння з 1
2     c     2     mb    -- Співпадіння для 2
2     c     2     nx    -- Друге співпадіння для 2
NULL  NULL  NULL  m0    -- NULL з правої таблиці
NULL  NULL  4     xy    -- Значення тільки в правій
NULL  NULL  5     tf    -- Значення тільки в правій
```

### Пояснення кожного рядка:

1. **Значення 1**:
   - Співпадає з обома записами в лівій таблиці
   - Створює два рядки результату

2. **Значення 2**:
   - Теж має два співпадіння
   - Кожне співпадіння створює окремий рядок

3. **NULL значення**:
   - NULL з правої таблиці включається
   - Стовпці з лівої заповнюються NULL

4. **Значення 4 та 5**:
   - Присутні тільки в правій таблиці
   - Ліві стовпці заповнюються NULL

## Використання псевдонімів

### Приклад з вибірковими стовпцями:
```sql
SELECT 
    a.C1,
    a.C2,
    b.C3
FROM table1 a
RIGHT JOIN table2 b
ON a.C1 = b.C1;
```

### Переваги використання псевдонімів:
1. Коротший та чіткіший код
2. Легше читати та підтримувати
3. Уникнення конфліктів імен
4. Більш зручна робота з кількома таблицями

## Важливі особливості

### При роботі з RIGHT JOIN:
1. Всі рядки з правої таблиці зберігаються
2. NULL значення не створюють співпадінь
3. Відсутні значення доповнюються NULL
4. Порядок таблиць має значення

### Рекомендації:
1. Перевіряйте результати на тестових даних
2. Використовуйте псевдоніми для більшої ясності
3. Вибирайте тільки необхідні стовпці
4. Враховуйте можливість множинних співпадінь

#  LEFT ANTI JOIN та RIGHT ANTI JOIN в SQL

## LEFT ANTI JOIN

### Визначення
LEFT ANTI JOIN повертає рядки з лівої таблиці, які НЕ мають відповідників у правій таблиці.

### Синтаксис:
```sql
SELECT *
FROM table1
LEFT JOIN table2
ON table1.C1 = table2.C1
WHERE table2.column IS NULL;
```

### Принцип роботи:
1. Спочатку виконується LEFT JOIN
2. Потім фільтруються рядки, де значення з правої таблиці NULL
3. Результат містить тільки унікальні рядки з лівої таблиці

## RIGHT ANTI JOIN

### Визначення
RIGHT ANTI JOIN повертає рядки з правої таблиці, які НЕ мають відповідників у лівій таблиці.

### Синтаксис:
```sql
SELECT *
FROM table1
RIGHT JOIN table2
ON table1.C1 = table2.C1
WHERE table1.column IS NULL;
```

### Принцип роботи:
1. Спочатку виконується RIGHT JOIN
2. Потім фільтруються рядки, де значення з лівої таблиці NULL
3. Результат містить тільки унікальні рядки з правої таблиці

## Визначення лівої та правої таблиці

### Правило:
- Ліва таблиця = перша таблиця в запиті
- Права таблиця = друга таблиця в запиті (після JOIN)

### Приклад:
```sql
SELECT *
FROM table1    -- Ліва таблиця
LEFT JOIN table2    -- Права таблиця
ON table1.C1 = table2.C1
```

## Особливості роботи з NULL

### Важливі моменти:
1. NULL значення не створюють співпадінь
2. WHERE column IS NULL використовується для фільтрації
3. Можна використовувати будь-який стовпець для перевірки NULL

## Практичні поради

### При використанні ANTI JOIN:
1. Правильно визначайте таблиці (ліва/права)
2. Перевіряйте умови з'єднання
3. Враховуйте NULL значення
4. Використовуйте відповідні індекси

### Типові сценарії використання:
1. Пошук відсутніх записів
2. Перевірка цілісності даних
3. Знаходження унікальних записів
4. Аналіз розбіжностей між таблицями


# Практичне застосування LEFT та RIGHT ANTI JOIN в SQL

## LEFT ANTI JOIN

### Визначення та призначення
- Повертає лише ті записи з лівої таблиці, які не мають відповідників у правій таблиці
- Використовується для пошуку унікальних записів у лівій таблиці

### Реалізація через LEFT JOIN:
```sql
SELECT *
FROM table1
LEFT JOIN table2
ON table1.C1 = table2.C1
WHERE table2.column IS NULL;
```

### Принцип роботи:
1. Спочатку виконується LEFT JOIN
2. Відбираються тільки ті рядки, де значення з правої таблиці NULL
3. У результаті отримуємо записи, що є тільки в лівій таблиці

## RIGHT ANTI JOIN

### Визначення та призначення
- Повертає лише ті записи з правої таблиці, які не мають відповідників у лівій таблиці
- Використовується для пошуку унікальних записів у правій таблиці

### Реалізація через RIGHT JOIN:
```sql
SELECT *
FROM table1
RIGHT JOIN table2
ON table1.C1 = table2.C1
WHERE table1.column IS NULL;
```

### Принцип роботи:
1. Спочатку виконується RIGHT JOIN
2. Відбираються тільки ті рядки, де значення з лівої таблиці NULL
3. У результаті отримуємо записи, що є тільки в правій таблиці

## Обробка NULL значень

### Особливості:
1. NULL ніколи не дорівнює NULL при порівнянні
2. NULL використовується як індикатор відсутності співпадінь
3. Можна використовувати будь-який стовпець для перевірки на NULL

### Поведінка при з'єднанні:
- NULL значення не створюють співпадінь
- Рядки з NULL значеннями обробляються окремо
- NULL в умові WHERE працює як фільтр

## Визначення лівої та правої таблиці

### Правило:
```sql
SELECT *
FROM table1    -- Завжди ліва таблиця
LEFT/RIGHT JOIN table2    -- Завжди права таблиця
ON...
```

### Важливі моменти:
1. Порядок таблиць важливий
2. Перша таблиця в FROM - завжди ліва
3. Таблиця після JOIN - завжди права
4. Це правило працює для всіх типів JOIN

## Практичні рекомендації

### При написанні запитів:
1. Чітко визначайте, які записи потрібно отримати
2. Правильно обирайте тип ANTI JOIN
3. Перевіряйте умови з'єднання
4. Враховуйте можливі NULL значення

### Оптимізація:
1. Використовуйте індекси для стовпців з'єднання
2. Обмежуйте кількість стовпців у результаті
3. Перевіряйте план виконання запиту
4. Тестуйте на репрезентативних даних


#  FULL OUTER JOIN в SQL

## Визначення FULL OUTER JOIN

### Компоненти результату:
1. Результати INNER JOIN
2. Унікальні записи з лівої таблиці
3. Унікальні записи з правої таблиці

### Базовий синтаксис:
```sql
SELECT *
FROM table1
FULL OUTER JOIN table2
ON table1.C1 = table2.C1;
```

## Особливості роботи

### Обробка співпадінь:
1. Спочатку знаходяться всі співпадіння (як в INNER JOIN)
2. Додаються записи, що є тільки в лівій таблиці
3. Додаються записи, що є тільки в правій таблиці

### Обробка NULL:
- NULL значення не створюють співпадінь
- Для неспівпадаючих записів відповідні поля заповнюються NULL
- NULL з обох таблиць обробляються окремо

## Практичне використання

### Базовий запит з усіма стовпцями:
```sql
SELECT *
FROM table1 a
FULL OUTER JOIN table2 b
ON a.C1 = b.C1;
```

### Вибір конкретних стовпців:
```sql
SELECT 
    a.C1,
    a.C2,
    b.C3
FROM table1 a
FULL OUTER JOIN table2 b
ON a.C1 = b.C1;
```

## Важливі застереження

### Обмеження використання:
1. Збільшує кількість результуючих записів
2. Може суттєво впливати на продуктивність
3. Потребує більше ресурсів при обробці
4. Не рекомендується для великих наборів даних

### Альтернативи:
1. Використання INNER JOIN де можливо
2. Комбінація LEFT та RIGHT JOIN
3. UNION ALL з відфільтрованими даними
4. Окремі запити для різних випадків

## Практичні поради

### При використанні FULL OUTER JOIN:
1. Перевіряйте необхідність використання
2. Обмежуйте кількість стовпців у результаті
3. Використовуйте відповідні індекси
4. Тестуйте на репрезентативних даних

### Оптимізація:
1. Фільтруйте дані до з'єднання
2. Використовуйте підходящі типи даних
3. Створюйте необхідні індекси
4. Моніторте продуктивність запитів


#  SELF JOIN в SQL

## Основи SELF JOIN

### Визначення
- SELF JOIN - це з'єднання таблиці самої з собою
- Використовуються різні псевдоніми для однієї таблиці
- Працює як звичайний JOIN, але з тією самою таблицею

### Базовий синтаксис:
```sql
SELECT *
FROM table1 a
INNER JOIN table1 b
ON a.C1 = b.C1;
```

## Приклади використання

### Повний запит:
```sql
-- Отримання всіх стовпців
SELECT *
FROM table1 a
INNER JOIN table1 b
ON a.C1 = b.C1;
```

### Вибіркові стовпці:
```sql
-- Вибір конкретних стовпців
SELECT 
    a.C1,
    b.C2
FROM table1 a
INNER JOIN table1 b
ON a.C1 = b.C1;
```

## Особливості роботи

### Обробка даних:
1. Таблиця використовується двічі з різними псевдонімами
2. Кожен рядок порівнюється з кожним
3. NULL значення не створюють співпадінь
4. Результат може містити більше рядків ніж вихідна таблиця

### Результат з'єднання для рядка з значенням "1":
```
a.C1  a.C2  b.C1  b.C2
--    --    --    --
1     a     1     a    -- Співпадіння з собою
1     a     1     b    -- Співпадіння з іншим записом
1     b     1     a    -- Зворотне співпадіння
1     b     1     b    -- Співпадіння з собою
```

## Практичні поради

### При написанні запитів:
1. Використовуйте зрозумілі псевдоніми
2. Чітко визначайте умови з'єднання
3. Обмежуйте кількість стовпців у результаті
4. Враховуйте можливість дублювання даних

### Оптимізація:
1. Використовуйте індекси для стовпців з'єднання
2. Фільтруйте дані до з'єднання
3. Уникайте зайвих стовпців у результаті
4. Використовуйте WHERE для додаткової фільтрації

## Спрощений синтаксис

### Варіанти запису:
```sql
-- Повний синтаксис
SELECT * FROM table1 a INNER JOIN table1 b ON ...

-- Спрощений синтаксис
SELECT * FROM table1 a JOIN table1 b ON ...
```

### Особливості:
- Обидва варіанти дають однаковий результат
- Спрощений варіант коротший
- INNER можна пропустити
- Результат виконання ідентичний

# Оператори UNION та UNION ALL в SQL

## Основні поняття

### UNION ALL
- Об'єднує результати всіх запитів
- Зберігає дублікати записів
- Швидший за UNION, бо не видаляє дублікати

### UNION
- Об'єднує результати з видаленням дублікатів
- Повертає тільки унікальні записи
- Потребує більше ресурсів через перевірку дублікатів

## Синтаксис

### Базовий приклад:
```sql
-- З дублікатами
SELECT C1, C2, C3 FROM append1
UNION ALL
SELECT C1, C2, C3 FROM append2;

-- Без дублікатів
SELECT C1, C2, C3 FROM append1
UNION
SELECT C1, C2, C3 FROM append2;
```

## Важливі правила

### 1. Кількість стовпців:
- Кількість стовпців має бути однаковою в усіх запитах
- Помилка виникне при різній кількості стовпців

### 2. Типи даних:
- Відповідні стовпці повинні мати сумісні типи даних
- Помилка конвертації при несумісних типах

### 3. Порядок стовпців:
- Порядок стовпців має бути однаковим
- Важливо для правильного співставлення даних

## Особливості роботи з псевдонімами

### Правило псевдонімів:
```sql
SELECT 
    C1 AS column1,
    C2 AS column2,
    C3 AS column3
FROM append1
UNION
SELECT 
    C1 AS other1,
    C2 AS other2,
    C3 AS other3
FROM append2;
-- Результат використовує псевдоніми з першого запиту
```

### Важливо пам'ятати:
- Використовуються псевдоніми першого запиту
- Псевдоніми наступних запитів ігноруються
- Важливо для зрозумілості результатів

## Практичні поради

### При використанні UNION:
1. Використовуйте UNION ALL якщо дублікати допустимі
2. Перевіряйте типи даних перед об'єднанням
3. Дотримуйтесь однакового порядку стовпців
4. Використовуйте зрозумілі псевдоніми

### Оптимізація:
1. UNION ALL працює швидше за UNION
2. Фільтруйте дані до об'єднання
3. Використовуйте відповідні індекси
4. Перевіряйте план виконання запиту


#  Оператор LIKE та шаблони пошуку в SQL

## Основи використання LIKE

### Спеціальні символи (wildcards):
1. `%` - заміняє нуль або більше символів
2. `_` - заміняє рівно один символ

## Приклади використання

### 1. Пошук за початком рядка:
```sql
-- Прізвища, що починаються на 'S'
SELECT * FROM employees_us
WHERE last_name LIKE 'S%';
```

### 2. Пошук за кінцем рядка:
```sql
-- Імена, що закінчуються на 'a'
SELECT * FROM employees_us
WHERE first_name LIKE '%a';
```

### 3. Пошук входження підрядка:
```sql
-- Департаменти, що містять 'eng'
SELECT * FROM employees_us
WHERE department LIKE '%eng%';
```

### 4. Точна довжина рядка:
```sql
-- Прізвища з 5 символів
SELECT * FROM employees_us
WHERE last_name LIKE '_____';
```

## Складні шаблони пошуку

### Пошук за декількома символами:
```sql
-- Імена, що починаються з 'C' або 'D'
SELECT * FROM employees_us
WHERE first_name LIKE '[CD]%';
```

### Комбінування умов:
```sql
-- Прізвища, що починаються з 'Br' або 'Bl'
SELECT * FROM employees_us
WHERE last_name LIKE 'BR%' 
   OR last_name LIKE 'BL%';
```

## Пошук з використанням NOT LIKE

### Виключення значень:
```sql
-- Імена без літери 'o'
SELECT * FROM employees_us
WHERE first_name NOT LIKE '%o%';
```

## Складні приклади

### Пошук за позицією символу:
```sql
-- Третій символ 'a' в імені
SELECT * FROM employees_us
WHERE first_name LIKE '__a%';
```

### Пошук за діапазоном символів:
```sql
-- Прізвища, що починаються з A-L
SELECT * FROM employees_us
WHERE last_name LIKE '[A-L]%';
```

### Пошук голосних/приголосних:
```sql
-- Імена, що починаються з голосної
SELECT * FROM employees_us
WHERE first_name LIKE '[AEIOU]%';

-- Імена, що починаються з приголосної
SELECT * FROM employees_us
WHERE first_name LIKE '[^AEIOU]%';
```

## Практичні поради

### При використанні LIKE:
1. Враховуйте регістр символів
2. Перевіряйте спеціальні символи
3. Використовуйте відповідні індекси
4. Уникайте шаблонів, що починаються з '%'

### Оптимізація:
1. Використовуйте точніші шаблони де можливо
2. Обмежуйте область пошуку
3. Враховуйте продуктивність при великих даних
4. Використовуйте альтернативні методи для простих порівнянь

#  Оператор CASE в SQL

## Основи CASE

### Базовий синтаксис:
```sql
CASE
    WHEN умова1 THEN результат1
    WHEN умова2 THEN результат2
    ELSE результат3
END AS назва_стовпця
```

### Принцип роботи:
1. Послідовна перевірка умов
2. Повернення результату першої істинної умови
3. Виконання ELSE якщо жодна умова не істинна
4. Завершення конструкції через END

## Приклади використання

### Категоризація за ціною:
```sql
SELECT *,
    CASE
        WHEN price > 500 THEN 'high'
        WHEN price BETWEEN 200 AND 500 THEN 'medium'
        ELSE 'low'
    END AS [price_category]
FROM products;
```

### Особливості роботи з NULL:
- Якщо відсутній ELSE, для невідповідних умов повертається NULL
- NULL можна явно вказати в ELSE
- NULL в умовах потребує спеціальної обробки

## Використання в ORDER BY

### Приклад сортування за категоріями:
```sql
SELECT * 
FROM products
ORDER BY
    CASE 
        WHEN category = 'electronics' THEN 1
        WHEN category = 'furniture' THEN 2
        ELSE 3
    END;
```

### Альтернативний запис:
```sql
SELECT * 
FROM products
ORDER BY
    CASE category
        WHEN 'electronics' THEN 1
        WHEN 'furniture' THEN 2
        WHEN 'accessories' THEN 3
    END;
```

## Практичні поради

### При написанні CASE:
1. Завжди включайте ELSE для обробки непередбачених випадків
2. Перевіряйте порядок умов (від специфічних до загальних)
3. Використовуйте зрозумілі назви для нових стовпців
4. Враховуйте можливі NULL значення

### Оптимізація:
1. Уникайте складних обчислень в умовах
2. Використовуйте індекси де можливо
3. Групуйте схожі умови
4. Спрощуйте складні умови

## Типові сценарії використання

### В SELECT:
- Категоризація даних
- Форматування виводу
- Обробка NULL значень
- Умовні обчислення

### В ORDER BY:
- Користувацьке сортування
- Пріоритезація даних
- Складне сортування за кількома умовами
- Динамічне визначення порядку сортування

# Вкладені оператори CASE в SQL

## Поняття вкладених CASE

### Визначення:
- Оператор CASE всередині іншого CASE
- Дозволяє створювати складну логіку категоризації
- Використовується для багаторівневих умов

## Приклад використання

### Категоризація товарів за двома параметрами:
```sql
SELECT *,
CASE
    WHEN category = 'electronics' THEN
        CASE
            WHEN price >= 300 THEN 'premium electronics'
            ELSE 'affordable electronics'
        END
    WHEN category = 'furniture' THEN
        CASE
            WHEN price >= 250 THEN 'premium furniture'
            ELSE 'affordable furniture'
        END
    ELSE
        CASE
            WHEN price >= 25 THEN 'premium accessories'
            ELSE 'affordable accessories'
        END
END AS [groups]
FROM products;
```

### Альтернативний синтаксис:
```sql
SELECT *,
CASE
    WHEN category = 'electronics' THEN
        CASE
            WHEN price >= 300 THEN 'premium electronics'
            ELSE 'affordable electronics'
        END
    WHEN category = 'furniture' THEN
        CASE
            WHEN price >= 250 THEN 'premium furniture'
            ELSE 'affordable furniture'
        END
    WHEN category = 'accessories' THEN
        CASE
            WHEN price >= 25 THEN 'premium accessories'
            ELSE 'affordable accessories'
        END
END AS [groups]
FROM products;
```

## Особливості роботи

### Порядок виконання:
1. Спочатку перевіряється зовнішній CASE
2. При співпадінні виконується внутрішній CASE
3. Кожен CASE повинен мати END
4. Результат повертається після всіх перевірок

### Важливі моменти:
1. Чітка ієрархія умов
2. Правильне закриття всіх CASE
3. Правильний порядок перевірок
4. Обробка всіх можливих випадків

## Практичні поради

### При написанні вкладених CASE:
1. Дотримуйтесь правильного форматування
2. Перевіряйте всі можливі комбінації
3. Використовуйте зрозумілі назви категорій
4. Коментуйте складну логіку

### Оптимізація:
1. Спрощуйте умови де можливо
2. Уникайте надмірної вкладеності
3. Розглядайте альтернативні підходи
4. Тестуйте на різних наборах даних

## Типові випадки використання

### Бізнес-сценарії:
1. Категоризація товарів
2. Цінова сегментація
3. Складні правила знижок
4. Багаторівнева класифікація


# Типи даних в SQL Server

## Важливість правильного вибору типів даних

### Основні причини:
1. Оптимізація використання пам'яті
2. Підвищення продуктивності
3. Забезпечення цілісності даних
4. Економія місця при великих об'ємах даних

## Текстові типи даних

### CHAR та VARCHAR:
- CHAR(n) - фіксована довжина
- VARCHAR(n) - змінна довжина
- Приклад використання CHAR(1) для статі (M/F)
- VARCHAR(256) для імен

### NCHAR та NVARCHAR:
- Підтримка Unicode-символів
- NCHAR для фіксованої довжини
- NVARCHAR для змінної довжини
- Використовуються для багатомовного контенту

## Числові типи даних

### Цілі числа:
- TINYINT (0-255, 1 байт)
- SMALLINT (більший діапазон)
- INT (4 байти)
- BIGINT (найбільший діапазон)

### Приклади використання:
```sql
-- Для віку людини
age TINYINT  -- достатньо 0-255

-- Для віку будівель
age SMALLINT -- може перевищувати 255
```

### Десяткові числа:
```sql
-- DECIMAL(p,s)
-- p - загальна кількість цифр
-- s - кількість цифр після коми
DECIMAL(5,2) -- для чисел типу 999.99
```

## Дати та час

### Основні типи:
- DATE - тільки дата
- TIME - тільки час
- DATETIME - дата та час разом

## Практичні рекомендації

### При виборі типу даних:
1. Визначити мінімальні та максимальні значення
2. Врахувати необхідність Unicode
3. Оцінити об'єм даних
4. Врахувати майбутні потреби

### Оптимізація:
1. Використовувати найменший достатній тип
2. Уникати надмірних розмірів
3. Враховувати особливості індексації
4. Регулярно аналізувати використання пам'яті



# Створення таблиць та вставка даних в SQL

## Створення таблиці

### Базовий синтаксис:
```sql
CREATE TABLE student_details (
    student_name NVARCHAR(256),
    gender CHAR(1),
    age TINYINT,
    event_date DATE,
    distance DECIMAL(5,2)
);
```

### Вибір типів даних:
1. **student_name**: NVARCHAR(256)
   - Змінна довжина
   - Підтримка Unicode
   - Достатній розмір для імен

2. **gender**: CHAR(1)
   - Фіксована довжина
   - Значення 'M' або 'F'

3. **age**: TINYINT
   - Діапазон 0-255
   - Достатній для віку людини

4. **event_date**: DATE
   - Тільки дата
   - Без часу

5. **distance**: DECIMAL(5,2)
   - 5 цифр всього
   - 2 після коми

## Вставка даних

### INSERT з вказанням стовпців:
```sql
INSERT INTO student_details 
(student_name, gender, age, event_date, distance)
VALUES 
('Raj Mehra', 'M', 25, '2024-08-03', 123.11);
```

### INSERT без вказання стовпців:
```sql
INSERT INTO student_details VALUES 
('Nathan Singh', 'M', 32, '2023-12-06', 119.09);
```

## Важливі моменти

### При створенні таблиці:
1. Правильно вибирати типи даних
2. Враховувати обмеження на значення
3. Визначати необхідні розміри полів
4. Перевіряти створену структуру

### При вставці даних:
1. Дотримуватися порядку стовпців
2. Враховувати типи даних
3. Використовувати правильний формат дат
4. Перевіряти вставлені дані

## Управління базами даних

### Створення бази даних:
```sql
CREATE DATABASE student;
```

### Видалення таблиці:
```sql
DROP TABLE student_details;
```

### Перевірка даних:
```sql
SELECT * FROM student_details;
```

## Практичні поради

### При роботі з таблицями:
1. Завжди вибирати правильну базу даних
2. Перевіряти існування таблиць
3. Використовувати відповідні типи даних
4. Тестувати на невеликих наборах даних

### При вставці даних:
1. Перевіряти формат даних
2. Враховувати обмеження
3. Використовувати транзакції при необхідності
4. Робити резервні копії важливих даних



#  Вставка множинних записів в SQL

## Вставка кількох записів одночасно

### Базовий синтаксис:
```sql
INSERT INTO student_details VALUES 
('Mayank', 'M', 18, '2024-02-02', 115.35),
('Mahesh', 'M', 34, '2023-11-08', 324.66);
```

### Особливості:
1. Записи розділяються комами
2. Кожен запис у власних дужках
3. Формат даних однаковий для всіх записів
4. Вставляються всі одночасно

## Визначення порядку стовпців

### Перевірка порядку:
```sql
SELECT * 
FROM information_schema.columns 
WHERE table_name = 'student_details';
```

### Ordinal Position показує:
1. student_name (1)
2. gender (2)
3. age (3)
4. event_date (4)
5. distance (5)

## Вставка в конкретні стовпці

### Синтаксис з вказанням стовпців:
```sql
INSERT INTO student_details 
(student_name, gender)
VALUES 
('Priya', 'F');
```

### Особливості:
1. Явно вказуються потрібні стовпці
2. Інші стовпці отримують NULL
3. Порядок значень відповідає порядку стовпців
4. Можна вставляти неповні дані

## Практичні поради

### При множинній вставці:
1. Перевіряти порядок стовпців
2. Дотримуватися форматів даних
3. Використовувати транзакції
4. Перевіряти результати

### При частковій вставці:
1. Враховувати NULL-значення
2. Перевіряти обмеження на NULL
3. Вказувати явно потрібні стовпці
4. Контролювати цілісність даних

## Часті помилки

### При вставці даних:
1. Неправильний порядок стовпців
2. Невідповідність типів даних
3. Порушення обмежень
4. Пропуск обов'язкових полів

### Рекомендації:
1. Завжди перевіряти структуру таблиці
2. Використовувати скрипти для тестування
3. Робити резервні копії
4. Документувати формат даних


# Обмеження типів даних при вставці в SQL

## Вставка в окремі стовпці

### Синтаксис:
```sql
INSERT INTO student_details 
(age, event_date)
VALUES 
(34, '2023-10-04'),
(43, '2019-01-01'),
(19, '2022-08-08');
```

### Особливості:
1. Вказуються тільки потрібні стовпці
2. Інші стовпці отримують NULL
3. Можна вставляти кілька записів
4. Порядок значень відповідає порядку стовпців

## Перевірка типів даних

### Запит структури таблиці:
```sql
SELECT * 
FROM information_schema.columns 
WHERE table_name = 'student_details';
```

### Важливі колонки:
- data_type: тип даних стовпця
- character_maximum_length: максимальна довжина
- numeric_precision: точність для чисел
- is_nullable: чи дозволені NULL

## Обмеження TINYINT

### Характеристики:
- Діапазон: 0-255
- Розмір: 1 байт
- Не допускає десяткові значення
- Не допускає від'ємні значення

### Приклад помилки:
```sql
-- Спроба вставити значення поза діапазоном
INSERT INTO student_details (age)
VALUES (256);
-- Результат: arithmetic overflow error
```

## Практичні поради

### При вставці даних:
1. Перевіряти типи даних стовпців
2. Враховувати діапазони значень
3. Валідувати дані перед вставкою
4. Обробляти потенційні помилки

### Запобігання помилкам:
1. Документувати обмеження типів даних
2. Тестувати на граничних значеннях
3. Використовувати відповідні типи даних
4. Перевіряти вхідні дані

## Обробка помилок

### Типи помилок:
1. Переповнення (overflow)
2. Невідповідність типів
3. Порушення обмежень
4. NULL в обов'язкових полях

### Рекомендації:
1. Розуміти повідомлення про помилки
2. Логувати проблемні вставки
3. Використовувати транзакції
4. Мати план відновлення даних


# Копіювання даних між таблицями в SQL

## Випадок 1: Нова таблиця не існує

### Копіювання всієї таблиці:
```sql
-- Створення нової таблиці з усіма даними
SELECT *
INTO new_table1
FROM dbo.sales;
```

### Копіювання окремих стовпців:
```sql
-- Копіювання тільки вибраних стовпців
SELECT product_id, quantity
INTO new_table1
FROM dbo.sales;
```

## Випадок 2: Таблиця вже існує

### Створення порожньої структури:
```sql
-- Метод 1: Використання TOP 0
SELECT TOP 0 *
INTO new_table2
FROM dbo.sales;

-- Метод 2: Використання FALSE умови
SELECT *
INTO new_table3
FROM dbo.sales
WHERE 1 = 0;
```

### Копіювання даних в існуючу таблицю:
```sql
-- Копіювання всіх даних
INSERT INTO new_table2
SELECT * FROM dbo.sales;

-- Копіювання окремих стовпців
INSERT INTO new_table3 (product_id, sale_date)
SELECT product_id, sale_date
FROM dbo.sales;
```

## Особливості різних методів

### При копіюванні всієї структури:
1. Створюється точна копія структури
2. Копіюються всі обмеження
3. Індекси не копіюються
4. Тригери не копіюються

### При копіюванні окремих стовпців:
1. Створюється частково структура
2. Решта стовпців отримують NULL
3. Потрібно явно вказувати стовпці
4. Типи даних зберігаються

## Практичні поради

### При створенні нової таблиці:
1. Перевіряти існування таблиці
2. Враховувати обмеження по місцю
3. Перевіряти права доступу
4. Контролювати цілісність даних

### При копіюванні даних:
1. Перевіряти відповідність типів даних
2. Використовувати транзакції
3. Враховувати обсяг даних
4. Логувати процес копіювання

## Важливі зауваження:
1. Методи з `TOP 0` та `WHERE 1=0` дають однаковий результат
2. `INSERT INTO` вимагає існування таблиці
3. При частковому копіюванні решта стовпців отримують NULL
4. Потрібно враховувати обмеження цільової таблиці


# Підзапити в SQL

## Основи підзапитів

### Визначення:
- Підзапит - це запит всередині іншого запиту
- Внутрішній запит виконується першим
- Результат використовується у зовнішньому запиті

## Приклади використання

### Пошук клієнтів за датою замовлення:
```sql
-- Знайти клієнтів, які зробили замовлення в серпні
SELECT * 
FROM customers 
WHERE customer_id IN (
    SELECT DISTINCT customer_id 
    FROM orders 
    WHERE order_date BETWEEN '2024-08-01' AND '2024-08-31'
);
```

### Пошук клієнтів без замовлень у певному періоді:
```sql
-- Знайти клієнтів, які не робили замовлень у серпні
SELECT * 
FROM customers 
WHERE customer_id IN (
    SELECT DISTINCT customer_id 
    FROM orders 
    WHERE order_date NOT BETWEEN '2024-08-01' AND '2024-08-31'
);
```

## Підзапити з агрегатними функціями

### Приклад пошуку по середньому значенню:
```sql
-- Знайти співробітників із зарплатою вище середньої
SELECT * 
FROM employees 
WHERE salary > (
    SELECT AVG(salary) 
    FROM employees
);
```

## Особливості роботи

### При використанні IN:
1. Підзапит повертає список значень
2. Зовнішній запит перевіряє входження
3. Можна використовувати NOT IN
4. Врахувати можливі NULL

### При порівнянні з агрегатами:
1. Підзапит повертає одне значення
2. Використовуються оператори порівняння
3. Можна комбінувати умови
4. Перевіряти типи даних

## Практичні поради

### При написанні підзапитів:
1. Спочатку тестувати підзапит окремо
2. Перевіряти продуктивність
3. Розглянути альтернативи (JOIN)
4. Використовувати відповідні індекси

### Оптимізація:
1. Уникати складних підзапитів
2. Використовувати відповідні індекси
3. Розглянути можливість використання JOIN
4. Перевіряти план виконання запиту

#  Обмеження NOT NULL в SQL

## Основи обмежень

### Визначення:
- Обмеження - це умови для стовпців таблиці
- Перевіряються при вставці даних
- Забезпечують цілісність даних

## Випадок 1: Створення нової таблиці

### Синтаксис:
```sql
CREATE TABLE test_not_null (
    eid INT NOT NULL,
    age TINYINT,
    first_name VARCHAR(256)
);
```

### Перевірка nullable стовпців:
```sql
SELECT * 
FROM information_schema.columns 
WHERE table_name = 'test_not_null';
```

### Приклади вставки даних:
```sql
-- Успішна вставка
INSERT INTO test_not_null 
VALUES (1, 23, 'Mayank');

-- Помилка: спроба вставити NULL в NOT NULL стовпець
INSERT INTO test_not_null 
VALUES (NULL, 25, 'Raj');

-- Успішна вставка NULL в nullable стовпці
INSERT INTO test_not_null 
VALUES (2, NULL, 'Raj');
```

## Випадок 2: Модифікація існуючої таблиці

### Додавання NOT NULL обмеження:
```sql
ALTER TABLE test_not_null
ALTER COLUMN first_name VARCHAR(256) NOT NULL;
```

### Особливості модифікації:
1. Можна додати NOT NULL тільки якщо стовпець не містить NULL
2. Потрібно спочатку оновити дані
3. Зберігається тип даних
4. Можливі помилки при наявності NULL

## Практичні поради

### При створенні таблиці:
1. Визначити, які стовпці не можуть бути NULL
2. Правильно вибрати типи даних
3. Документувати обмеження
4. Планувати структуру даних

### При модифікації обмежень:
1. Перевірити наявність NULL значень
2. Підготувати дані перед зміною
3. Використовувати транзакції
4. Тестувати на копії даних

## Помилки та їх обробка

### Типові помилки:
1. Вставка NULL в NOT NULL стовпець
2. Модифікація стовпця з NULL значеннями
3. Неправильний тип даних
4. Відсутність значень за замовчуванням

### Рекомендації:
1. Завжди перевіряти дані перед модифікацією
2. Мати план відкату змін
3. Документувати зміни
4. Тестувати всі сценарії


#  Обмеження UNIQUE в SQL

## Основи UNIQUE обмеження

### Визначення:
- Забезпечує унікальність значень у стовпці
- Дозволяє NULL (але тільки один раз)
- Може комбінуватися з іншими обмеженнями

## Випадок 1: Створення нової таблиці

### Синтаксис:
```sql
CREATE TABLE test_unique (
    sid INT UNIQUE,
    age TINYINT NOT NULL,
    first_name VARCHAR(256) NOT NULL UNIQUE,
    last_name VARCHAR(256)
);
```

### Особливості роботи з NULL:
```sql
-- Дозволяє один NULL
INSERT INTO test_unique VALUES (NULL, 34, 'Akhilesh', 'Jen');

-- Другий NULL викликає помилку
INSERT INTO test_unique VALUES (NULL, 54, 'Nitin', 'Singh');
```

## Випадок 2: Модифікація існуючої таблиці

### Додавання UNIQUE обмеження:
```sql
ALTER TABLE test_unique
ADD UNIQUE (last_name);
```

### Важливі моменти:
1. Таблиця не повинна містити дублікатів
2. Потрібно очистити дані перед додаванням
3. Можливе використання TRUNCATE
4. Перевірка існуючих даних

## Комбінування обмежень

### Приклади комбінацій:
```sql
-- UNIQUE та NOT NULL
first_name VARCHAR(256) NOT NULL UNIQUE

-- Тільки UNIQUE
sid INT UNIQUE

-- Без обмежень
last_name VARCHAR(256)
```

## Обробка помилок

### Типові помилки:
1. Спроба вставки дубліката
2. Спроба вставки другого NULL
3. Порушення обмеження при оновленні
4. Додавання обмеження до стовпця з дублікатами

### Повідомлення про помилки:
1. Violation of UNIQUE constraint
2. Duplicate key value
3. Cannot insert duplicate key

## Практичні поради

### При створенні таблиці:
1. Визначити потребу в унікальності
2. Врахувати NULL значення
3. Планувати комбінації обмежень
4. Документувати обмеження

### При модифікації таблиці:
1. Перевірити існуючі дані
2. Підготувати дані
3. Використовувати транзакції
4. Мати план відкату змін


#  Обмеження CHECK в SQL

## Основи CHECK обмеження

### Визначення:
- Перевіряє задані умови для стовпців
- Запобігає вставці недопустимих значень
- Може застосовуватися до кількох стовпців

## Випадок 1: Створення нової таблиці

### Синтаксис:
```sql
CREATE TABLE test_check (
    id INT,
    first_name VARCHAR(256),
    age TINYINT CHECK (age >= 10)
);
```

### Перевірка роботи:
```sql
-- Успішна вставка
INSERT INTO test_check VALUES (1, 'Mayank', 20);

-- Помилка: порушення CHECK обмеження
INSERT INTO test_check VALUES (2, 'Raj', 9);
```

## Випадок 2: Додавання CHECK до існуючої таблиці

### Синтаксис:
```sql
ALTER TABLE test_check
ADD CHECK (id > 5);
```

### Особливості:
1. Перевіряються існуючі дані
2. Потрібно оновити невідповідні дані
3. Можливе використання UPDATE
4. Важлива послідовність дій

## Обробка помилок

### Типові помилки:
```sql
-- Конфлікт з існуючими даними
The ALTER TABLE statement conflicted with the CHECK constraint

-- Порушення при вставці
The INSERT statement conflicted with the CHECK constraint
```

### Вирішення проблем:
1. Оновлення існуючих даних
2. Перевірка перед додаванням обмеження
3. Використання транзакцій
4. Планування змін

## Практичні поради

### При створенні таблиці:
1. Визначити необхідні умови
2. Врахувати бізнес-правила
3. Планувати діапазони значень
4. Документувати обмеження

### При модифікації таблиці:
1. Перевірити існуючі дані
2. Підготувати дані до змін
3. Використовувати транзакції
4. Мати план відкату

## Приклади використання

### Типові перевірки:
1. Діапазони значень
2. Порівняння між стовпцями
3. Перевірка формату даних
4. Комплексні умови

### Складні обмеження:
```sql
-- Перевірка діапазону
CHECK (age BETWEEN 10 AND 100)

-- Множинні умови
CHECK (salary > 0 AND salary < max_salary)
```


