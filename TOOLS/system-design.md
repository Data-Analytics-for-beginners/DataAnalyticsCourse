


 - How I Learned System Design, https://medium.com/@himanshusingour7/how-i-learned-system-design-d7444d454367
 - System Design was HARD until I Learned these 30 Concepts, https://medium.com/algomaster-io/system-design-was-hard-until-i-learned-these-30-concepts-78042ff99cae
 - LeetCode was HARD until I Learned these 15 Patterns, https://medium.com/algomaster-io/leetcode-was-hard-until-i-learned-these-15-patterns-19d15f6d71f1
 - 50 Scenario-Based System Design Questions for Senior Developer Interviews — Part 1/5, https://medium.com/thesystemdesign/50-scenario-based-system-design-questions-for-senior-developer-interviews-part-1-5-667c85cf32b1
 - System Design for Data Engineers, https://medium.com/@akanksha_singh/system-design-for-data-engineers-65cf66abf325
 - Authentication Explained: When to Use Basic, Bearer, OAuth2, JWT & SSO, https://levelup.gitconnected.com/authentication-explained-when-to-use-basic-bearer-oauth2-jwt-sso-b2418c1af939
 - On the Design of Personal Finance Management Systems Based on Artificial Intelligence Within a Major French Retail Bank, https://medium.com/@david-serrault/on-the-design-of-personal-finance-management-systems-based-on-artificial-intelligence-and-machine-b58898265d2f
 - Fundamentals of system design, https://medium.com/@gaurikhard/fundamentals-of-system-design-97d276142ddf
 - Design Systems vs Libraries: Why Designers and Developers See Design Systems Differently, https://medium.com/design-systems-collective/design-systems-vs-libraries-why-designers-and-developers-see-design-systems-differently-089e78800a1d
 - System Design Easy: A Beginner’s Guide That Actually Makes Sense, https://medium.com/gitconnected/system-design-easy-a-beginners-guide-that-actually-makes-sense-2d8265c7c12d
 - Event-Driven Everything: How to Think (and Build) in Events Instead of Requests, https://medium.com/@attara/event-driven-everything-how-to-think-and-build-in-events-instead-of-requests-617f63ca6164
 - Building Architecture as a Capability: From Project-Based Thinking to Product-Centric Execution, https://medium.com/@attara/building-architecture-as-a-capability-from-project-based-thinking-to-product-centric-execution-0304fc278273
 - Design an Ebook Distribution Platform, https://medium.com/@ankitviddya/design-an-ebook-distribution-platform-4ddb2b8d56fb
 - Design a Real-Time Stock Trading Platform, https://medium.com/@ankitviddya/design-a-real-time-stock-trading-platform-d4537cf5d0c7
 - Design a Nested Comments System, https://medium.com/@ankitviddya/design-a-nested-comments-system-189dc195f008
 - Design a CAPTCHA System, https://medium.com/@ankitviddya/design-a-captcha-system-090df3d63072
 - System Design: API Architectural Styles, https://medium.com/@cinish/system-design-api-architectural-styles-bce5bf5404ff
 - System Design: Distributed system patterns, https://medium.com/@cinish/system-design-distributed-system-patterns-ded944556523
 - System design:Key data structures, https://medium.com/@cinish/system-design-key-data-structures-31257fa72f19
 - Every Layer of an HLD Interview and the Tradeoffs That Make or Break Your Design, https://medium.com/@kanishks772/every-layer-of-an-hld-interview-and-the-tradeoffs-that-make-or-break-your-design-d78f81b9c99a
   
------------------------------------------------------------------------------------------------------------


# Системний дизайн - це процес планування того, як система повинна працювати, включаючи її структуру, компоненти, потік даних та взаємодію між частинами. Це допомагає будувати системи, які є масштабованими, надійними, ефективними та легкими в обслуговуванні.

## Основні цілі системного дизайну:

- **Масштабованість** (обробка зростання)
- **Точність**
- **Оптимізація**
- **Ефективність**
- **Надійність**
- **Повнота**
- **Висока продуктивність**

## Поширені компоненти в системному дизайні:

- **Балансувальник навантаження:** Розподіляє трафік між серверами
- **Сховище ключ-значення:** Зберігає дані в форматі ключ-значення (як Redis)
- **Блокове/Файлове сховище:** Зберігає файли або блоки даних (як S3)
- **Віртуальні машини (VM):** Симульовані комп'ютери для розгортання
- **Системи моніторингу:** Відстежують продуктивність та помилки
- **Черги повідомлень:** Для комунікації між сервісами (наприклад, Kafka)
- **Генератори унікальних ID:** Створюють унікальні ідентифікатори в системах
- **Розподілений пошук:** Допомагає з пошуком даних великого масштабу (як Elasticsearch)
- **Системи логування:** Зберігають логи для відстеження та налагодження
- **Планувальники завдань:** Планують завдання як щоденні резервні копії або пакетну обробку

## Типи системних архітектур:

### **Клієнт-Сервер**
Frontend (клієнт) спілкується з backend (сервером). Це базова веб-модель.

### **Подієво-орієнтована**
Код реагує на події як кліки користувача, завантаження файлів тощо. Популярна в serverless функціях.

### **Мікроядро**
Мінімальна основна система з опціональними плагінами або сервісами. Часто зустрічається в ядрах ОС.

### **Мікросервіси**
Система розбита на незалежні сервіси. Кожен сервіс має свою базу даних і обробляє одну функцію (наприклад, сервіс логіну, платіжний сервіс). Сервіси спілкуються через API.

## Життєвий цикл системного дизайну:

1. **Планування**
2. **Дослідження доцільності**
3. **Системний дизайн**
4. **Впровадження**
5. **Тестування**
6. **Розгортання**
7. **Обслуговування**

## Важливі терміни:

### **Затримка (Latency)**
Час, необхідний для переміщення даних з однієї точки в іншу (менше = краще).

### **Пропускна здатність (Throughput)**
Кількість даних, переданих за час (більше = краще), часто вимірюється в бітах за секунду (bps).

### **Доступність (Availability)**
Час роботи системи, зазвичай записується в "дев'ятках":
- 90% = 1 дев'ятка
- 99% = 2 дев'ятки
- 99.9% = 3 дев'ятки
- 99.999% = 5 дев'яток (використовується в банківських або критично важливих додатках)

## Для збільшення доступності можна:

- Використовувати розподілені системи замість монолітів
- Додавати резервні сервери в різних локаціях (гео-резервування)
- Проектувати для відмовостійкості

## Для зменшення затримки можна використовувати:

### **CDN (Мережі доставки контенту)**
Це периферійні сервери, розміщені глобально для швидшої доставки контенту користувачам.

### **Резервування**
Створення дублікатів компонентів (як сервери або бази даних) для забезпечення роботи системи у випадку відмови одного.

### **Узгодженість**
Забезпечення того, щоб всі користувачі бачили однакові дані одночасно (детальний розбір в теоремі CAP пізніше).

## Час у розподілених системах:

- **Фізичні годинники** можуть дрейфувати (йти занадто швидко або повільно)
- **Логічні годинники** (як Lamport Clocks) допомагають підтримувати порядок подій у системах
- **Перекіс годинника** - коли дві системи мають різний час
- **Швидкість дрейфу** - як швидко годинники втрачають синхронізацію

## Serverful vs. Serverless:

### **Serverful**
Ви керуєте серверами, контролюєте як вони працюють і налаштовуєте все. Найкраще для:
- Веб-додатків
- Систем баз даних
- Чатів реального часу або ігор
- Додатків, що потребують стабільної високої продуктивності

### **Serverless**
Ви пишете функції, а хмарний провайдер керує серверами за вас. Найкраще для:
- Мікросервісів
- API
- Фонових завдань
- Подієво-орієнтованих додатків
- IoT додатків

## Потоки (Threads):

**Потоки** - це легкі одиниці виконання в межах процесу.
Кожен потік має свій власний стек і працює незалежно, але ділить пам'ять з іншими потоками.

### Потоки включають:
- **Thread ID** - Унікальний ідентифікатор
- **Лічильник програми** - Відстежує поточну інструкцію
- **Набір регістрів** - Зберігає тимчасові дані
- **Стек** - Зберігає виклики функцій та змінні

### Два типи потоків:

#### **Потоки рівня користувача**
Керуються бібліотеками. Швидкі, але обмежені (не можуть легко використовувати кілька ядер).

#### **Потоки рівня ядра**
Керуються ОС. Повільніші, але потужніші, підтримують справжнє паралельне виконання.

### **Перемикання контексту**
Перемикання CPU з одного потоку на інший. Перемикання контексту рівня користувача швидке, рівня ядра повільніше через накладні витрати ОС.

## Горизонтальне vs. Вертикальне масштабування:

### **Вертикальне масштабування (Scale Up)**
Додавання більше потужності (CPU/RAM) до одного сервера
- Легше налаштування
- Безпечно для малих додатків
- Не потребує складного розділення даних
- **Але:** одна точка відмови, дорого на великому масштабі

### **Горизонтальне масштабування (Scale Out)**
Додавання більше серверів для обробки більше користувачів
- Краща відмовостійкість
- Краще для розподілених систем
- Потребує балансування навантаження
- Трохи складніше, але відмінно для зростання

## Як вибрати стратегію масштабування:

- **SQL DB + Малий додаток** → Використовуйте Вертикальне
- **NoSQL DB + Великий масштаб або глобальний трафік** → Використовуйте Горизонтальне
- **Монолітна система** → Вертикальне
- **Мікросервіси/Контейнеризована система** → Горизонтальне
- **Високошвидкісні, високодоступні додатки** → Перевага Горизонтальному
- **Чутливі до вартості додатки** → Перевага Вертикальному (на меншому масштабі)

## Як працює Інтернет (Базовий огляд):

1. Ви вводите URL веб-сайту (наприклад, google.com)
2. Браузер запитує DNS перетворити домен на IP-адресу
3. Браузер встановлює TCP-з'єднання з сервером, використовуючи цю IP
4. HTTP/HTTPS використовується для відправки/отримання даних
5. HTTPS включає шифрування, використовуючи SSL/TLS
6. Дані подорожують через маршрутизатори та комутатори, щоб досягнути сервера
7. Відповідь повертається назад до браузера
8. CDN можуть доставляти кешовані версії з найближчих серверів

## Питання для співбесіди (Розділ 1 — Основи)

1. **Яка різниця між serverful та serverless архітектурою? Наведіть реальні випадки використання.**

2. **Як балансувальник навантаження допомагає в обробці трафіку?**

3. **Що таке затримка? Як можна зменшити її в системі з високим трафіком?**

4. **Як би ви проектували для високої доступності в розподіленій системі?**

5. **Порівняйте вертикальне та горизонтальне масштабування. Коли б ви використовували кожне?**

6. **Що таке перемикання контексту в потоках? Чому це важливо для продуктивності?**

7. **Які переваги мікросервісів над монолітним дизайном?**

8. **Як CDN допомагає в покращенні продуктивності системи?**

9. **Яка різниця між фізичними та логічними годинниками в розподілених системах?**

10. **Поясніть, як працює DNS-запит при завантаженні веб-сторінки.**

11. **Як би ви спроектували систему, яка може обробляти 1 мільйон одночасних користувачів?**

12. **Чому відмовостійкість важлива? Як розподілені системи досягають її?**

13. **Яка роль черг повідомлень у системному дизайні?**

14. **Яка різниця між пропускною здатністю та затримкою?**


-----------------------------------------------------------------


# Інтерв'ю з Високорівневого Дизайну (HLD) - це не просто малювання коробок та стрілок. Вони про демонстрацію вашої здатності навігувати складними компромісами на кожному рівні розподіленої системи. Кожне рішення, яке ви приймаєте, створює хвильові ефекти, які можуть або зміцнити, або зруйнувати вашу архітектуру. Давайте розберемо критичні рівні, де ваші дизайнерські рішення будуть ретельно перевірені.

Натисніть enter або клікніть, щоб переглянути зображення в повному розмірі

## 1. Рівні OSI моделі: Рішення мережевої основи

### Вибір фізичного/канального рівня: Ethernet vs WiFi vs 5G
Для глобальних додатків розуміння впливу підключення є критичним. 5G дозволяє додатки реального часу, але має обмежене покриття. WiFi забезпечує стабільність, але створює обмеження мобільності.

### Компроміси мережевого рівня: IPv4 vs IPv6, розміщення периферії CDN
IPv6 пропонує величезний адресний простір, але прийняття відрізняється глобально. Рішення щодо розміщення периферії CDN впливають на затримку - ближчі вузли зменшують RTT, але збільшують витрати на інфраструктуру.

### Транспортний рівень: TCP vs UDP vs QUIC
TCP гарантує доставку, але додає накладні витрати. UDP дозволяє ігри реального часу та відео, але потребує надійності на рівні додатку. QUIC поєднує надійність TCP з продуктивністю UDP, але потребує сучасної інфраструктури.

**Ключовий компроміс:** Для сервісу відеострімінгу UDP може забезпечити нижчу затримку, але чи можете ви грамотно обробляти втрату пакетів? Інтерв'ювер хоче бачити, що ви розумієте, що вибір мережевого рівня каскадно впливає на поведінку додатку.

## 2. Рівень протоколу додатку: API комунікація

### Вибір: REST vs GraphQL vs gRPC vs WebSockets

Ваше рішення про протокол додатку підсилює вибір мережевого рівня. REST через HTTP/2 зменшує накладні витрати з'єднання, але може призвести до надмірного отримання даних. GraphQL забезпечує гнучкість запитів, але ускладнює стратегії кешування. gRPC ефективно використовує мультиплексування HTTP/2, але потребує підтримки бінарного протоколу.

**Ключовий компроміс:** Розгляньте мобільних клієнтів на нестабільних мережах - безстанова природа REST допомагає з переключеннями, але пакетування GraphQL зменшує використання пропускної здатності при поганому підключенні.

## 3. Проблеми рівня сесії та презентації

### Управління сесіями: Липкі сесії vs Розподілені сесії vs JWT
Липкі сесії спрощують логіку додатку, але створюють вузькі місця масштабування. Розподілені сховища сесій (Redis) дозволяють горизонтальне масштабування, але додають мережеву затримку. JWT усувають серверне зберігання, але створюють виклики відкликання токенів.

### Серіалізація даних: JSON vs Protocol Buffers vs Avro vs MessagePack
JSON пропонує читабельність для людини, але споживає більше пропускної здатності. Protocol Buffers забезпечують компактний бінарний формат, але потребують планування еволюції схеми. Avro дозволяє еволюцію схеми, але додає складність.

**Ключовий компроміс:** Для комунікації мікросервісів Protocol Buffers зменшують використання мережі на 60%, але потребують підтримки .proto файлів між командами. Чи варта продуктивність операційних накладних витрат?

## 4. Балансування навантаження: Стратегії розподілу трафіку

### Вибір: Round Robin vs Зважений vs Найменше з'єднань vs Консистентне хешування

Це не просто про розподіл запитів, це про розуміння поведінки вашої системи під навантаженням. Round robin працює для безстанових сервісів, але не вдається з липкими сесіями. Консистентне хешування запобігає інвалідації кешу під час масштабування, але може створювати гарячі точки.

**Ключовий компроміс:** Для платформи електронної комерції під час Чорної п'ятниці найменше з'єднань може здатися ідеальним для обробки різних часів обробки, але що відбувається, коли один сервер розвиває витік пам'яті? Ваша стратегія балансування навантаження повинна враховувати як нормальні операції, так і сценарії відмов.

## 5. Механізми кешування: Множник продуктивності

### Вибір: Redis vs Memcached vs CDN vs Кешування на рівні додатку

Рішення про кешування розкривають ваше розуміння патернів доступу до даних. Redis пропонує персистентність та складні структури даних, але споживає більше пам'яті. Memcached забезпечує чисту швидкість для простих операцій ключ-значення. CDN відмінно працюють для статичного контенту, але мають проблеми з персоналізованими даними.

**Ключовий компроміс:** Розгляньте новинну платформу: CDN кешування для статей має сенс, але що з персоналізованими рекомендаціями? Вам потрібен Redis для складних операцій, але чи можете ви дозволити собі накладні витрати пам'яті? Інтерв'ювер хоче бачити, як ви балансуєте прирости продуктивності проти витрат на інфраструктуру та складності.

## 6. Черги повідомлень: Асинхронна обробка

### Вибір: Kafka vs RabbitMQ vs SQS vs Redis Pub/Sub

Вибір черги впливає на все від консистентності даних до операційних накладних витрат. Kafka забезпечує довговічність та можливості відтворення, але потребує значної операційної експертизи. RabbitMQ пропонує гнучку маршрутизацію, але може стати вузьким місцем. SQS спрощує операції, але вводить прив'язку до постачальника.

**Ключовий компроміс:** Для системи обробки платежів довговічність Kafka може здатися важливою, але чи може ваша команда справитися з її операційною складністю? Іноді простіша модель RabbitMQ, незважаючи на нижчу пропускну здатність, може бути прагматичним вибором. Інтерв'ювер оцінює, чи можете ви збалансувати технічний ідеалізм з практичними обмеженнями.

## 7. Теорема CAP: Фундаментальне обмеження

### Вибір: Консистентність vs Доступність vs Стійкість до розділення

Кожна розподілена система повинна пожертвувати одним аспектом CAP. Це не теоретично - це безпосередньо впливає на користувацький досвід та бізнес-вимоги. Банківські системи зазвичай вибирають консистентність над доступністю, в той час як платформи соціальних мереж часто пріоритизують доступність.

**Ключовий компроміс:** Для чат-додатку, чи пріоритизуєте ви доставку повідомлень (доступність) або ідеальний порядок (консистентність)? Ваш вибір впливає не тільки на технічну архітектуру, але також на продуктові вимоги. Чи може бізнес толерувати евентуальну консистентність у порядку повідомлень, якщо це означає кращий uptime?

## 8. Архітектура бази даних: Стратегія зберігання даних

### Вибір: SQL vs NoSQL vs NewSQL, Шардинг vs Реплікація vs Федерація

Рішення про базу даних мають найтривалший вплив на вашу систему. SQL бази даних забезпечують ACID гарантії, але мають проблеми з горизонтальним масштабуванням. NoSQL пропонує масштабованість, але жертвує гнучкістю запитів. Шардинг покращує продуктивність, але ускладнює join'и та транзакції.

**Ключовий компроміс:** Для додатку каршерингу вам потрібні геопросторові запити (на користь MongoDB), але також сильна консистентність для платежів (на користь PostgreSQL). Інтерв'ювер хоче бачити, чи виберете ви підхід поліглотної персистентності або знайдете творчі рішення в рамках однієї парадигми бази даних.

## Мета-компроміс: Складність vs Простота

На всіх рівнях всеосяжною напругою є між складними рішеннями та операційною простотою. Архітектура мікросервісів Netflix дозволяє масивний масштаб, але потребує армій інженерів. Монолітний підхід може краще служити 90% компаній, незважаючи на те, що він менш гламурний.

## Як навігувати HLD інтерв'ю

### Почніть з вимог
Кожне рішення про компроміс повинно відстежуватися до конкретних бізнес-вимог. Не оптимізуйте передчасно.

### Визнавайте альтернативи
При виборі Redis замість Memcached явно згадайте, від чого ви відмовляєтесь (ефективність пам'яті) та що отримуєте (персистентність даних).

### Розглядайте еволюцію
Як ваші вибори вплинуть на систему, коли вона масштабується від 1,000 до 1 мільйона до 100 мільйонів користувачів?

### Операційна реальність
Найкраще технічне рішення нічого не означає, якщо ваша команда не може його підтримувати. Враховуйте експертизу команди та операційні накладні витрати.

### Квантифікуйте, коли можливо
Замість "кращої продуктивності" уточніть "зменшує затримку з 200мс до 50мс при нормальному навантаженні."

## Переможний склад розуму

HLD інтерв'ю не про знаходження "правильної" відповіді, вони про демонстрацію системного мислення про складні компроміси. Інтерв'ювер хоче бачити, як ви міркуєте через обмеження, визнаєте альтернативи та приймаєте принципові рішення, які балансують конкуруючі пріоритети.

**Пам'ятайте:** кожен рівень вашого дизайну розповідає історію про ваше інженерне судження. Переконайтеся, що це історія про продумані компроміси, а не довільні вибори.

Ваша здатність навігувати цими рівнями, підтримуючи когерентне міркування по всій системі, відрізняє старших інженерів від молодших. Оволодійте компромісами, і ви оволодієте інтерв'ю.
