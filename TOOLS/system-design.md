


 - System Design was HARD until I Learned these 30 Concepts, https://medium.com/algomaster-io/system-design-was-hard-until-i-learned-these-30-concepts-78042ff99cae
 - LeetCode was HARD until I Learned these 15 Patterns, https://medium.com/algomaster-io/leetcode-was-hard-until-i-learned-these-15-patterns-19d15f6d71f1
 - 50 Scenario-Based System Design Questions for Senior Developer Interviews — Part 1/5, https://medium.com/thesystemdesign/50-scenario-based-system-design-questions-for-senior-developer-interviews-part-1-5-667c85cf32b1
 - System Design for Data Engineers, https://medium.com/@akanksha_singh/system-design-for-data-engineers-65cf66abf325
 - Authentication Explained: When to Use Basic, Bearer, OAuth2, JWT & SSO, https://levelup.gitconnected.com/authentication-explained-when-to-use-basic-bearer-oauth2-jwt-sso-b2418c1af939
 - On the Design of Personal Finance Management Systems Based on Artificial Intelligence Within a Major French Retail Bank, https://medium.com/@david-serrault/on-the-design-of-personal-finance-management-systems-based-on-artificial-intelligence-and-machine-b58898265d2f
 - Fundamentals of system design, https://medium.com/@gaurikhard/fundamentals-of-system-design-97d276142ddf
   
------------------------------------------------------------------------------------------------------------


# Системний дизайн - це процес планування того, як система повинна працювати, включаючи її структуру, компоненти, потік даних та взаємодію між частинами. Це допомагає будувати системи, які є масштабованими, надійними, ефективними та легкими в обслуговуванні.

## Основні цілі системного дизайну:

- **Масштабованість** (обробка зростання)
- **Точність**
- **Оптимізація**
- **Ефективність**
- **Надійність**
- **Повнота**
- **Висока продуктивність**

## Поширені компоненти в системному дизайні:

- **Балансувальник навантаження:** Розподіляє трафік між серверами
- **Сховище ключ-значення:** Зберігає дані в форматі ключ-значення (як Redis)
- **Блокове/Файлове сховище:** Зберігає файли або блоки даних (як S3)
- **Віртуальні машини (VM):** Симульовані комп'ютери для розгортання
- **Системи моніторингу:** Відстежують продуктивність та помилки
- **Черги повідомлень:** Для комунікації між сервісами (наприклад, Kafka)
- **Генератори унікальних ID:** Створюють унікальні ідентифікатори в системах
- **Розподілений пошук:** Допомагає з пошуком даних великого масштабу (як Elasticsearch)
- **Системи логування:** Зберігають логи для відстеження та налагодження
- **Планувальники завдань:** Планують завдання як щоденні резервні копії або пакетну обробку

## Типи системних архітектур:

### **Клієнт-Сервер**
Frontend (клієнт) спілкується з backend (сервером). Це базова веб-модель.

### **Подієво-орієнтована**
Код реагує на події як кліки користувача, завантаження файлів тощо. Популярна в serverless функціях.

### **Мікроядро**
Мінімальна основна система з опціональними плагінами або сервісами. Часто зустрічається в ядрах ОС.

### **Мікросервіси**
Система розбита на незалежні сервіси. Кожен сервіс має свою базу даних і обробляє одну функцію (наприклад, сервіс логіну, платіжний сервіс). Сервіси спілкуються через API.

## Життєвий цикл системного дизайну:

1. **Планування**
2. **Дослідження доцільності**
3. **Системний дизайн**
4. **Впровадження**
5. **Тестування**
6. **Розгортання**
7. **Обслуговування**

## Важливі терміни:

### **Затримка (Latency)**
Час, необхідний для переміщення даних з однієї точки в іншу (менше = краще).

### **Пропускна здатність (Throughput)**
Кількість даних, переданих за час (більше = краще), часто вимірюється в бітах за секунду (bps).

### **Доступність (Availability)**
Час роботи системи, зазвичай записується в "дев'ятках":
- 90% = 1 дев'ятка
- 99% = 2 дев'ятки
- 99.9% = 3 дев'ятки
- 99.999% = 5 дев'яток (використовується в банківських або критично важливих додатках)

## Для збільшення доступності можна:

- Використовувати розподілені системи замість монолітів
- Додавати резервні сервери в різних локаціях (гео-резервування)
- Проектувати для відмовостійкості

## Для зменшення затримки можна використовувати:

### **CDN (Мережі доставки контенту)**
Це периферійні сервери, розміщені глобально для швидшої доставки контенту користувачам.

### **Резервування**
Створення дублікатів компонентів (як сервери або бази даних) для забезпечення роботи системи у випадку відмови одного.

### **Узгодженість**
Забезпечення того, щоб всі користувачі бачили однакові дані одночасно (детальний розбір в теоремі CAP пізніше).

## Час у розподілених системах:

- **Фізичні годинники** можуть дрейфувати (йти занадто швидко або повільно)
- **Логічні годинники** (як Lamport Clocks) допомагають підтримувати порядок подій у системах
- **Перекіс годинника** - коли дві системи мають різний час
- **Швидкість дрейфу** - як швидко годинники втрачають синхронізацію

## Serverful vs. Serverless:

### **Serverful**
Ви керуєте серверами, контролюєте як вони працюють і налаштовуєте все. Найкраще для:
- Веб-додатків
- Систем баз даних
- Чатів реального часу або ігор
- Додатків, що потребують стабільної високої продуктивності

### **Serverless**
Ви пишете функції, а хмарний провайдер керує серверами за вас. Найкраще для:
- Мікросервісів
- API
- Фонових завдань
- Подієво-орієнтованих додатків
- IoT додатків

## Потоки (Threads):

**Потоки** - це легкі одиниці виконання в межах процесу.
Кожен потік має свій власний стек і працює незалежно, але ділить пам'ять з іншими потоками.

### Потоки включають:
- **Thread ID** - Унікальний ідентифікатор
- **Лічильник програми** - Відстежує поточну інструкцію
- **Набір регістрів** - Зберігає тимчасові дані
- **Стек** - Зберігає виклики функцій та змінні

### Два типи потоків:

#### **Потоки рівня користувача**
Керуються бібліотеками. Швидкі, але обмежені (не можуть легко використовувати кілька ядер).

#### **Потоки рівня ядра**
Керуються ОС. Повільніші, але потужніші, підтримують справжнє паралельне виконання.

### **Перемикання контексту**
Перемикання CPU з одного потоку на інший. Перемикання контексту рівня користувача швидке, рівня ядра повільніше через накладні витрати ОС.

## Горизонтальне vs. Вертикальне масштабування:

### **Вертикальне масштабування (Scale Up)**
Додавання більше потужності (CPU/RAM) до одного сервера
- Легше налаштування
- Безпечно для малих додатків
- Не потребує складного розділення даних
- **Але:** одна точка відмови, дорого на великому масштабі

### **Горизонтальне масштабування (Scale Out)**
Додавання більше серверів для обробки більше користувачів
- Краща відмовостійкість
- Краще для розподілених систем
- Потребує балансування навантаження
- Трохи складніше, але відмінно для зростання

## Як вибрати стратегію масштабування:

- **SQL DB + Малий додаток** → Використовуйте Вертикальне
- **NoSQL DB + Великий масштаб або глобальний трафік** → Використовуйте Горизонтальне
- **Монолітна система** → Вертикальне
- **Мікросервіси/Контейнеризована система** → Горизонтальне
- **Високошвидкісні, високодоступні додатки** → Перевага Горизонтальному
- **Чутливі до вартості додатки** → Перевага Вертикальному (на меншому масштабі)

## Як працює Інтернет (Базовий огляд):

1. Ви вводите URL веб-сайту (наприклад, google.com)
2. Браузер запитує DNS перетворити домен на IP-адресу
3. Браузер встановлює TCP-з'єднання з сервером, використовуючи цю IP
4. HTTP/HTTPS використовується для відправки/отримання даних
5. HTTPS включає шифрування, використовуючи SSL/TLS
6. Дані подорожують через маршрутизатори та комутатори, щоб досягнути сервера
7. Відповідь повертається назад до браузера
8. CDN можуть доставляти кешовані версії з найближчих серверів

## Питання для співбесіди (Розділ 1 — Основи)

1. **Яка різниця між serverful та serverless архітектурою? Наведіть реальні випадки використання.**

2. **Як балансувальник навантаження допомагає в обробці трафіку?**

3. **Що таке затримка? Як можна зменшити її в системі з високим трафіком?**

4. **Як би ви проектували для високої доступності в розподіленій системі?**

5. **Порівняйте вертикальне та горизонтальне масштабування. Коли б ви використовували кожне?**

6. **Що таке перемикання контексту в потоках? Чому це важливо для продуктивності?**

7. **Які переваги мікросервісів над монолітним дизайном?**

8. **Як CDN допомагає в покращенні продуктивності системи?**

9. **Яка різниця між фізичними та логічними годинниками в розподілених системах?**

10. **Поясніть, як працює DNS-запит при завантаженні веб-сторінки.**

11. **Як би ви спроектували систему, яка може обробляти 1 мільйон одночасних користувачів?**

12. **Чому відмовостійкість важлива? Як розподілені системи досягають її?**

13. **Яка роль черг повідомлень у системному дизайні?**

14. **Яка різниця між пропускною здатністю та затримкою?**
