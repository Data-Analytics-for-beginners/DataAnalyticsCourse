

# Питання з SQL

## 1. Основи SQL
- [Вступ та підготовка бази даних](#основи-sql-та-базові-запити)
- [Основні запити SELECT](#питання-та-рішення)
- [Фільтрація даних (WHERE)](#питання-3-як-знайти-всіх-співробітників-які-працюють-у-відділі-it)
- [Сортування результатів (ORDER BY)](#питання-5-як-відсортувати-результати-за-прізвищем-у-порядку-зростання)
- [Вибір унікальних значень (DISTINCT)](#питання-6-як-вибрати-унікальні-відділи-з-таблиці-employees)
- [Агрегатні функції (COUNT, MAX, AVG)](#питання-7-як-знайти-кількість-співробітників-у-кожному-відділі)
- [Групування даних (GROUP BY)](#питання-7-як-знайти-кількість-співробітників-у-кожному-відділі)
- [Пошук за шаблоном (LIKE)](#питання-10-як-вибрати-співробітників-чиє-прізвище-починається-з-літери-м)

## 2. Складні умови в запитах WHERE
- [Оператор AND](#питання-1-як-вибрати-співробітників-які-працюють-у-відділі-it-та-мають-зарплату-більше-75-000)
- [Оператор OR](#питання-2-як-знайти-співробітників-які-працюють-у-відділі-hr-або-мають-зарплату-менше-60-000)
- [Оператор NOT](#питання-3-як-вибрати-співробітників-які-не-працюють-у-відділі-фінансів)
- [Оператор BETWEEN](#питання-4-як-знайти-співробітників-зарплата-яких-між-60-000-та-70-000-і-які-працюють-у-відділі-фінансів)
- [Групування умов за допомогою дужок](#питання-6-як-знайти-співробітників-які-працюють-у-відділі-hr-або-фінансів-і-мають-зарплату-більше-65-000)
- [Оператор IN](#важливі-моменти)
- [Комбінування різних операторів](#питання-9-як-вибрати-співробітників-які-працюють-у-відділі-it-і-або-мають-зарплату-більше-75-000-або-їхнє-імя--олена)

## 3. Об'єднання таблиць (JOIN)
- [Підготовка даних для JOIN](#підготовка-даних)
- [INNER JOIN](#задача-1-знайти-імена-клієнтів-які-зробили-замовлення)
- [LEFT JOIN](#задача-2-знайти-клієнтів-які-не-зробили-жодного-замовлення)
- [RIGHT JOIN](#задача-5-знайти-товари-які-ніколи-не-замовлялися)
- [Об'єднання кількох таблиць](#задача-7-вивести-клієнтів-товари-які-вони-замовили-та-дату-замовлення-включаючи-клієнтів-без-замовлень)
- [JOIN з агрегатними функціями](#задача-6-підрахувати-кількість-замовлень-для-кожного-клієнта)
- [Типи JOIN в SQL](#основні-типи-join-в-sql)

## 4. Розширені запити з JOIN
- [Самоз'єднання (SELF JOIN)](#задача-1-знайти-пари-клієнтів-які-живуть-в-одній-країні)
- [Використання віконних функцій](#задача-2-знайти-клієнта-який-витратив-найбільше-грошей-на-замовлення)
- [GROUP BY та HAVING з JOIN](#задача-3-знайти-клієнтів-які-замовили-більше-одного-типу-товару)
- [Вкладені запити з JOIN](#задача-7-знайти-клієнтів-які-замовили-той-самий-товар-більше-одного-разу)
- [Фільтрація даних після JOIN](#задача-5-отримати-всі-замовлення-зроблені-клієнтами-з-україни)
- [JOIN з умовами за значеннями](#задача-6-знайти-імена-клієнтів-які-замовили-товар-з-ціною-понад-500-гривень)

## 5. Спеціалізовані SQL запити
- [Знаходження другої найвищої зарплати](#знаходження-другої-найвищої-зарплати)
  - [Метод 1: Підзапити](#метод-1-використання-підзапитів)
  - [Метод 2: CTE та DENSE_RANK()](#метод-2-використання-cte-та-функції-dense_rank)
  - [Метод 3: Підзапити з DENSE_RANK()](#метод-3-підзапити-з-dense_rank)
  - [Метод 4: Підзапити з TOP](#метод-4-підзапити-з-top)
- [Ієрархічні запити (самоз'єднання)](#використання-самозєднання-self-join)
  - [Підготовка даних](#підготовка-даних-1)
  - [Основний запит з самоз'єднанням](#крок-1-основний-запит-з-самозєднанням)
  - [Обробка NULL-значень](#крок-2-додавання-співробітників-без-керівників)

## 6. Робота з дублікатами
- [Видалення повних дублікатів](#видалення-дублікатів-у-таблиці)
  - [Метод 1: ROW_NUMBER()](#метод-1-використання-row_number)
  - [Метод 2: Тимчасові таблиці](#метод-2-використання-тимчасової-таблиці)
- [Видалення часткових дублікатів](#видалення-часткових-дублікатів-у-таблиці)
  - [Варіант 1: Збереження записів з меншим ID](#варіант-1-зберегти-запис-з-меншим-employeeid)
  - [Варіант 2: Збереження записів з більшим ID](#варіант-2-зберегти-запис-з-більшим-employeeid)
  - [Додаткові критерії вибору](#додаткові-критерії-вибору)








#  Основи SQL та базові запити

Розглянемо базові запити SQL та розв'яжемо типові завдання, які часто зустрічаються на співбесідах. Це перший набір запитань з основ SQL, які допоможуть вам зрозуміти ключові концепції мови запитів.

## Підготовка бази даних
Спочатку створимо нову базу даних та таблицю для наших прикладів:

```sql
-- Створення бази даних
CREATE DATABASE [SQLBasicsQuestions];

-- Використання створеної бази даних
USE SQLBasicsQuestions;

-- Створення таблиці співробітників
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    Email VARCHAR(100),
    PhoneNumber VARCHAR(20),
    HireDate DATE,
    JobTitle VARCHAR(50),
    Salary DECIMAL(10, 2),
    Department VARCHAR(50),
    ManagerID INT
);

-- Заповнення таблиці даними
INSERT INTO Employees VALUES
    (1, 'Іван', 'Петренко', 'i.petrenko@company.com', '380991234567', '2020-01-15', 'Розробник', 75000.00, 'IT', 5),
    (2, 'Олена', 'Коваленко', 'o.kovalenko@company.com', '380992345678', '2019-03-20', 'Аналітик', 65000.00, 'Фінанси', 4),
    (3, 'Михайло', 'Мельник', 'm.melnyk@company.com', '380993456789', '2021-05-10', 'Дизайнер', 60000.00, 'IT', 5),
    (4, 'Наталія', 'Шевченко', 'n.shevchenko@company.com', '380994567890', '2018-11-05', 'Менеджер', 81000.00, 'Фінанси', NULL),
    (5, 'Андрій', 'Бондаренко', 'a.bondarenko@company.com', '380995678901', '2017-08-12', 'Керівник відділу', 78000.00, 'IT', NULL),
    (6, 'Софія', 'Мазур', 's.mazur@company.com', '380996789012', '2022-02-28', 'HR-менеджер', 62000.00, 'HR', 9),
    (7, 'Олексій', 'Ткаченко', 'o.tkachenko@company.com', '380997890123', '2020-09-14', 'Розробник', 72000.00, 'IT', 5),
    (8, 'Юлія', 'Кравченко', 'y.kravchenko@company.com', '380998901234', '2019-06-22', 'Бухгалтер', 68000.00, 'Фінанси', 4),
    (9, 'Віктор', 'Мороз', 'v.moroz@company.com', '380999012345', '2018-04-30', 'Директор HR', 79000.00, 'HR', NULL),
    (10, 'Марія', 'Лисенко', 'm.lysenko@company.com', '380990123456', '2021-11-17', 'Асистент', 55000.00, 'HR', 9);
```

## Питання та рішення

### Питання 1: Як вибрати всі стовпці з таблиці Employees?

```sql
SELECT * FROM Employees;
```

Цей запит поверне всі рядки та стовпці з таблиці "Employees".

### Питання 2: Як вибрати лише стовпці FirstName та LastName з таблиці Employees?

```sql
SELECT FirstName, LastName FROM Employees;
```

Такий запит поверне лише імена та прізвища всіх співробітників.

### Питання 3: Як знайти всіх співробітників, які працюють у відділі IT?

Можемо використати два підходи:

```sql
-- Варіант 1: з оператором рівності
SELECT * FROM Employees
WHERE Department = 'IT';

-- Варіант 2: з оператором LIKE
SELECT * FROM Employees
WHERE Department LIKE 'IT';
```

Обидва запити дадуть однаковий результат - список всіх співробітників відділу IT.

### Питання 4: Як вибрати співробітників із зарплатою більше 70 000?

```sql
SELECT * FROM Employees
WHERE Salary > 70000;
```

Цей запит відфільтрує співробітників і покаже лише тих, чия зарплата перевищує 70 000.

### Питання 5: Як відсортувати результати за прізвищем у порядку зростання?

```sql
-- Варіант 1: без явного вказання порядку сортування (за замовчуванням ASC)
SELECT * FROM Employees
ORDER BY LastName;

-- Варіант 2: з явним вказанням порядку сортування
SELECT * FROM Employees
ORDER BY LastName ASC;
```

Обидва запити дадуть однаковий результат - список співробітників, відсортований за прізвищем в алфавітному порядку.

### Питання 6: Як вибрати унікальні відділи з таблиці Employees?

```sql
SELECT DISTINCT Department FROM Employees;
```

Цей запит поверне список унікальних відділів без повторень: Фінанси, HR, IT.

### Питання 7: Як знайти кількість співробітників у кожному відділі?

```sql
-- Варіант 1: використовуючи COUNT(*)
SELECT Department, COUNT(*) AS [Кількість співробітників]
FROM Employees
GROUP BY Department;

-- Варіант 2: використовуючи COUNT(EmployeeID)
SELECT Department, COUNT(EmployeeID) AS [Кількість співробітників]
FROM Employees
GROUP BY Department;
```

Обидва запити повернуть кількість співробітників у кожному відділі. Оскільки EmployeeID є первинним ключем (не містить NULL або дублікатів), обидва варіанти дадуть однаковий результат.

### Питання 8: Як знайти максимальну зарплату в таблиці Employees?

```sql
SELECT MAX(Salary) AS [Максимальна зарплата]
FROM Employees;
```

Цей запит знайде найвищу зарплату серед усіх співробітників.

### Питання 9: Як знайти середню зарплату співробітників у відділі Фінанси?

```sql
SELECT AVG(Salary) AS [Середня зарплата у відділі Фінанси]
FROM Employees
WHERE Department = 'Фінанси';
```

Цей запит обчислить середню зарплату всіх співробітників, які працюють у відділі Фінанси.

### Питання 10: Як вибрати співробітників, чиє прізвище починається з літери "М"?

```sql
SELECT * FROM Employees
WHERE LastName LIKE 'М%';
```

Цей запит знайде всіх співробітників, чиє прізвище починається з літери "М".

## Висновок

Розглянули основні SQL-запити, які часто зустрічаються на співбесідах та у щоденній роботі з базами даних:

1. Базові запити з вибору даних (SELECT)
2. Фільтрацію даних за умовами (WHERE)
3. Сортування результатів (ORDER BY)
4. Вибір унікальних значень (DISTINCT)
5. Агрегатні функції (COUNT, MAX, AVG)
6. Групування даних (GROUP BY)
7. Пошук за шаблоном (LIKE)

Розуміння цих базових концепцій SQL є фундаментом для подальшого вивчення більш складних запитів та технік роботи з базами даних.


-------------------------------------------------------------------------------------------------------------------------------------------------------------

# Складні умови в запитах WHERE

Продовжимо вивчення SQL і зосередимось на більш складних умовах у операторі WHERE. Ми будемо використовувати ту саму таблицю `Employees`, що й раніше, яка знаходиться в базі даних `SQLBasicsQuestions`.

## Питання та рішення

### Питання 1: Як вибрати співробітників, які працюють у відділі IT та мають зарплату більше 75 000?

```sql
SELECT * FROM Employees
WHERE Department = 'IT' AND Salary >= 75000;
```

Цей запит використовує логічний оператор `AND` для об'єднання двох умов. Результат буде містити лише ті записи, які відповідають обом критеріям одночасно.

### Питання 2: Як знайти співробітників, які працюють у відділі HR або мають зарплату менше 60 000?

```sql
SELECT * FROM Employees
WHERE Department = 'HR' OR Salary < 60000;
```

Тут ми використовуємо логічний оператор `OR`. Запит поверне всіх співробітників, які відповідають хоча б одній з умов: або працюють у відділі HR, або мають зарплату менше 60 000.

### Питання 3: Як вибрати співробітників, які не працюють у відділі фінансів?

Є два способи написати цей запит:

```sql
-- Варіант 1: використання оператора NOT IN
SELECT * FROM Employees
WHERE Department NOT IN ('Фінанси');

-- Варіант 2: використання оператора !=
SELECT * FROM Employees
WHERE Department != 'Фінанси';
```

Обидва варіанти дають однаковий результат – список всіх співробітників, крім тих, хто працює у відділі фінансів.

### Питання 4: Як знайти співробітників, зарплата яких між 60 000 та 70 000, і які працюють у відділі фінансів?

```sql
SELECT * FROM Employees
WHERE Salary BETWEEN 60000 AND 70000 AND Department = 'Фінанси';
```

Цей запит використовує оператор `BETWEEN` для перевірки, чи зарплата знаходиться в заданому діапазоні, та оператор `AND` для перевірки відділу.

### Питання 5: Як знайти співробітників, які працюють у відділі IT і не мають зарплату більше 80 000?

Цей запит можна написати двома способами:

```sql
-- Варіант 1: використання оператора <=
SELECT * FROM Employees
WHERE Department = 'IT' AND Salary <= 80000;

-- Варіант 2: використання оператора NOT
SELECT * FROM Employees
WHERE Department = 'IT' AND NOT Salary > 80000;
```

Обидва варіанти дають однаковий результат – співробітників відділу IT із зарплатою, що не перевищує 80 000.

### Питання 6: Як знайти співробітників, які працюють у відділі HR або фінансів і мають зарплату більше 65 000?

```sql
SELECT * FROM Employees
WHERE (Department = 'HR' OR Department = 'Фінанси') AND Salary >= 65000;
```

У цьому запиті ми використовуємо дужки для групування умов. Спочатку виконується умова в дужках (співробітник працює в HR або фінансах), а потім перевіряється умова щодо зарплати.

### Питання 7: Як вибрати співробітників, прізвище яких починається з "К" і які не працюють у відділі HR?

```sql
SELECT * FROM Employees
WHERE LastName LIKE 'К%' AND Department != 'HR';
```

Цей запит використовує оператор `LIKE` з символом підстановки `%` для пошуку прізвищ, що починаються з літери "К", та логічний оператор `AND` для виключення співробітників відділу HR.

### Питання 8: Як знайти співробітників, які не працюють у відділі IT і мають зарплату більше 70 000?

```sql
SELECT * FROM Employees
WHERE Department != 'IT' AND Salary > 70000;
```

Цей запит поверне всіх співробітників, які одночасно відповідають обом умовам: не працюють у відділі IT та мають зарплату більше 70 000.

### Питання 9: Як вибрати співробітників, які працюють у відділі IT і або мають зарплату більше 75 000, або їхнє ім'я – "Олена"?

```sql
SELECT * FROM Employees
WHERE Department = 'IT' AND (Salary > 75000 OR FirstName = 'Олена');
```

У цьому запиті ми використовуємо дужки для групування умов. Запит поверне співробітників відділу IT, які мають або зарплату більше 75 000, або ім'я "Олена".

### Питання 10: Як знайти співробітників, які не працюють ні у відділі HR, ні у відділі IT?

```sql
SELECT * FROM Employees
WHERE Department NOT IN ('HR', 'IT');
```

Цей запит використовує оператор `NOT IN` з переліком значень для виключення співробітників, які працюють у відділах HR або IT.

## Важливі моменти

При роботі зі складними умовами у запитах WHERE важливо пам'ятати:

1. **Логічні оператори**:
   - `AND` – обидві умови мають бути істинними
   - `OR` – принаймні одна з умов має бути істинною
   - `NOT` – заперечення умови

2. **Використання дужок** для групування умов важливо для правильного порядку виконання. Наприклад:
   - `WHERE (умова1 OR умова2) AND умова3` – спочатку обчислюється вираз у дужках

3. **Оператор IN** можна використовувати замість кількох умов OR:
   - `WHERE Department IN ('HR', 'Фінанси')` еквівалентно `WHERE Department = 'HR' OR Department = 'Фінанси'`

4. **Оператор BETWEEN** спрощує перевірку на діапазон значень:
   - `WHERE Salary BETWEEN 60000 AND 70000` еквівалентно `WHERE Salary >= 60000 AND Salary <= 70000`

## Висновок

Розглянули складніші запити SQL з використанням оператора WHERE та різних логічних операторів. Ми навчилися:
- Об'єднувати умови за допомогою логічних операторів AND і OR
- Використовувати заперечення з оператором NOT
- Встановлювати пріоритет операцій за допомогою дужок
- Використовувати оператори IN, NOT IN і BETWEEN для більш компактного коду
- Поєднувати різні умови для створення складних фільтрів

Ці навички є важливими для ефективної роботи з базами даних та написання оптимальних запитів SQL, які точно відображають бізнес-вимоги.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Об'єднання таблиць за допомогою JOIN

Розглянемо важливу тему в SQL – об'єднання таблиць за допомогою операторів JOIN. Ми будемо працювати з трьома таблицями даних і розв'яжемо кілька практичних задач, які ілюструють використання різних типів JOIN.

## Підготовка даних
Спочатку створимо базу даних та таблиці для наших прикладів:

```sql
-- Створення бази даних
CREATE DATABASE SQLQuestions;

-- Використання створеної бази даних
USE SQLQuestions;

-- Створення таблиці клієнтів
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    CustomerName VARCHAR(50),
    Country VARCHAR(50)
);

-- Заповнення таблиці клієнтів
INSERT INTO Customers VALUES 
    (1, 'Іван Петренко', 'Україна'),
    (2, 'Марія Коваленко', 'Україна'),
    (3, 'Олександр Шевченко', 'Польща'),
    (4, 'Дмитро Сидоренко', 'Німеччина'),
    (5, 'Олена Іваненко', 'Україна');

-- Створення таблиці замовлень
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE,
    ProductID INT
);

-- Заповнення таблиці замовлень
INSERT INTO Orders VALUES 
    (101, 1, '2023-01-15', 1001),
    (102, 1, '2023-02-20', 1002),
    (103, 2, '2023-01-25', 1003),
    (104, 3, '2023-03-10', 1004),
    (105, 5, '2023-03-15', 1002);

-- Створення таблиці товарів
CREATE TABLE Products (
    ProductID INT PRIMARY KEY,
    ProductName VARCHAR(50),
    Price DECIMAL(10, 2)
);

-- Заповнення таблиці товарів
INSERT INTO Products VALUES 
    (1001, 'Ноутбук', 25000.00),
    (1002, 'Смартфон', 12000.00),
    (1003, 'Планшет', 8000.00),
    (1004, 'Навушники', 2500.00),
    (1005, 'Смарт-годинник', 5000.00);
```

Перевіримо створені таблиці:

```sql
SELECT * FROM Customers;
SELECT * FROM Orders;
SELECT * FROM Products;
```

## Зв'язки між таблицями
У нашій схемі даних:
- Таблиці `Customers` і `Orders` пов'язані через стовпець `CustomerID`
- Таблиці `Orders` і `Products` пов'язані через стовпець `ProductID`

Зверніть увагу, що клієнт з ID=4 (Дмитро Сидоренко) не має жодного замовлення, а товар з ID=1005 (Смарт-годинник) не був включений в жодне замовлення.

## Задачі з використанням JOIN

### Задача 1: Знайти імена клієнтів, які зробили замовлення

```sql
SELECT DISTINCT CustomerName
FROM Customers C
INNER JOIN Orders O ON O.CustomerID = C.CustomerID;
```

Цей запит використовує INNER JOIN для отримання списку клієнтів, які зробили принаймні одне замовлення. Результат не міститиме Дмитра Сидоренка, оскільки він не має жодного замовлення.

### Задача 2: Знайти клієнтів, які не зробили жодного замовлення

```sql
SELECT DISTINCT CustomerName
FROM Customers C
LEFT JOIN Orders O ON O.CustomerID = C.CustomerID
WHERE O.OrderID IS NULL;
```

Тут ми використовуємо LEFT JOIN у поєднанні з умовою WHERE для знаходження клієнтів, які не мають жодного замовлення. Результат міститиме лише Дмитра Сидоренка.

### Задача 3: Вивести всі замовлення разом з назвою товару та ціною

```sql
SELECT DISTINCT O.OrderID, P.ProductName, P.Price
FROM Orders O
JOIN Products P ON O.ProductID = P.ProductID;
```

У цьому запиті ми використовуємо INNER JOIN (скорочено просто JOIN) для об'єднання інформації про замовлення та товари, щоб отримати назву та ціну кожного замовленого товару.

### Задача 4: Знайти імена клієнтів та їхні замовлення, включаючи клієнтів без замовлень

```sql
SELECT DISTINCT C.CustomerName, O.OrderID
FROM Customers C
LEFT JOIN Orders O ON C.CustomerID = O.CustomerID;
```

Цей запит використовує LEFT JOIN, щоб отримати всіх клієнтів та їхні замовлення, включаючи клієнтів, які не мають замовлень (для них OrderID буде NULL).

### Задача 5: Знайти товари, які ніколи не замовлялися

```sql
SELECT DISTINCT P.ProductID, P.ProductName
FROM Products P
LEFT JOIN Orders O ON P.ProductID = O.ProductID
WHERE O.OrderID IS NULL;
```

Цей запит використовує LEFT JOIN з умовою WHERE для знаходження товарів, які не входять до жодного замовлення. Результат міститиме Смарт-годинник.

### Задача 6: Підрахувати кількість замовлень для кожного клієнта

```sql
SELECT C.CustomerName, COUNT(O.OrderID) AS [Кількість замовлень]
FROM Customers C
LEFT JOIN Orders O ON C.CustomerID = O.CustomerID
GROUP BY C.CustomerName;
```

У цьому запиті ми використовуємо LEFT JOIN та агрегатну функцію COUNT для підрахунку кількості замовлень кожного клієнта. LEFT JOIN забезпечує, що клієнти без замовлень також з'являться в результаті з кількістю 0.

### Задача 7: Вивести клієнтів, товари, які вони замовили, та дату замовлення, включаючи клієнтів без замовлень

```sql
SELECT DISTINCT C.CustomerName, P.ProductID, P.ProductName, O.OrderDate
FROM Customers C
LEFT JOIN Orders O ON C.CustomerID = O.CustomerID
LEFT JOIN Products P ON O.ProductID = P.ProductID;
```

Цей запит об'єднує всі три таблиці, використовуючи два LEFT JOIN. Спочатку ми з'єднуємо таблиці Customers та Orders за CustomerID, а потім результат об'єднуємо з таблицею Products за ProductID. Це дозволяє нам отримати повну інформацію про замовлення кожного клієнта, включаючи клієнтів без замовлень (для них дані товарів і дата будуть NULL).

## Основні типи JOIN в SQL

1. **INNER JOIN**: Повертає рядки, коли є збіги в обох таблицях.

2. **LEFT JOIN (або LEFT OUTER JOIN)**: Повертає всі рядки з лівої таблиці та збіги з правої таблиці. Якщо немає збігу, результат міститиме NULL для стовпців правої таблиці.

3. **RIGHT JOIN (або RIGHT OUTER JOIN)**: Повертає всі рядки з правої таблиці та збіги з лівої таблиці. Якщо немає збігу, результат міститиме NULL для стовпців лівої таблиці.

4. **FULL JOIN (або FULL OUTER JOIN)**: Повертає рядки, коли є збіг в одній із таблиць.

5. **CROSS JOIN**: Повертає декартовий добуток двох таблиць.

6. **SELF JOIN**: Об'єднання таблиці з самою собою.

## Важливі моменти при роботі з JOIN

1. **Аліаси таблиць**: Використовуйте аліаси для кращої читабельності запитів, особливо при об'єднанні багатьох таблиць.

2. **Уникайте неоднозначності**: Якщо стовпці з однаковими іменами присутні в кількох таблицях, вказуйте аліас таблиці при посиланні на ці стовпці (наприклад, `C.CustomerID` замість просто `CustomerID`).

3. **Використовуйте LEFT JOIN для включення "відсутніх" рядків**: Якщо вам потрібно включити рядки, які не мають відповідних значень в іншій таблиці, використовуйте LEFT JOIN.

4. **Фільтрація в LEFT JOIN**: Розміщуйте умови фільтрації для правої таблиці в умові ON, а не WHERE, якщо ви хочете зберегти всі рядки з лівої таблиці.

## Висновок

Розглянули різні типи JOIN в SQL та їх застосування для вирішення практичних задач. Ми навчилися:
- Знаходити дані, що відповідають умовам в обох таблицях (INNER JOIN)
- Включати рядки, що не мають відповідних значень (LEFT JOIN)
- Використовувати JOIN з агрегатними функціями та GROUP BY
- Об'єднувати більше двох таблиць
- Знаходити "відсутні" дані за допомогою LEFT JOIN і фільтрації NULL-значень

Вміння ефективно використовувати JOIN є критичним для роботи з реляційними базами даних та є однією з найважливіших навичок в SQL.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Розширені запити з використанням JOIN

## Вступ

Розглянемо більш складні запити з використанням JOIN, включаючи самоз'єднання (SELF JOIN), віконні функції та агрегатні функції з умовами.

Будемо працювати з тими самими трьома таблицями: `Customers`, `Orders` і `Products`, які ми створили раніше.

## Огляд даних

Спочатку перевіримо дані в наших таблицях:

```sql
SELECT * FROM Customers;
SELECT * FROM Orders;
SELECT * FROM Products;
```

### Таблиця Customers:
- `CustomerID` - ідентифікатор клієнта
- `CustomerName` - ім'я клієнта
- `Country` - країна клієнта

### Таблиця Orders:
- `OrderID` - ідентифікатор замовлення
- `CustomerID` - ідентифікатор клієнта (зв'язок з таблицею Customers)
- `OrderDate` - дата замовлення
- `ProductID` - ідентифікатор товару (зв'язок з таблицею Products)

### Таблиця Products:
- `ProductID` - ідентифікатор товару
- `ProductName` - назва товару
- `Price` - ціна товару

## Задача 1: Знайти пари клієнтів, які живуть в одній країні

Ця задача вимагає застосування самоз'єднання (SELF JOIN), коли таблиця об'єднується сама з собою.

```sql
SELECT X.CustomerName, Y.CustomerName
FROM Customers X
JOIN Customers Y ON X.Country = Y.Country
WHERE X.CustomerID <> Y.CustomerID
AND X.CustomerID > Y.CustomerID;
```

**Пояснення:**
1. Ми використовуємо самоз'єднання таблиці Customers, призначаючи їй два різні аліаси (X та Y)
2. Умова `X.Country = Y.Country` знаходить клієнтів з однієї країни
3. Умова `X.CustomerID <> Y.CustomerID` гарантує, що ми не порівнюємо клієнта із самим собою
4. Умова `X.CustomerID > Y.CustomerID` запобігає дублюванню результатів (інакше ми б отримали пари (A,B) і (B,A))

## Задача 2: Знайти клієнта, який витратив найбільше грошей на замовлення

Для вирішення цієї задачі нам потрібно об'єднати всі три таблиці та використати агрегатну функцію SUM.

```sql
SELECT CustomerName
FROM (
    SELECT C.CustomerName, SUM(P.Price) AS TotalSpent,
           DENSE_RANK() OVER (ORDER BY SUM(P.Price) DESC) AS DR
    FROM Customers C
    INNER JOIN Orders O ON C.CustomerID = O.CustomerID
    INNER JOIN Products P ON O.ProductID = P.ProductID
    GROUP BY C.CustomerName
) M
WHERE DR = 1;
```

**Пояснення:**
1. Внутрішній підзапит об'єднує три таблиці для отримання суми витрат кожного клієнта
2. Функція `DENSE_RANK()` присвоює ранг кожному клієнту за загальною сумою витрат (1 - найбільша сума)
3. Основний запит вибирає тільки клієнтів з рангом 1 (ті, хто витратив найбільше)

**Примітка:** Функція `DENSE_RANK()` дозволяє обробляти ситуації, коли кілька клієнтів витратили однакову суму, яка є максимальною.

## Задача 3: Знайти клієнтів, які замовили більше одного типу товару

```sql
SELECT CustomerName
FROM Customers C
JOIN Orders O ON C.CustomerID = O.CustomerID
GROUP BY CustomerName
HAVING COUNT(DISTINCT ProductID) > 1;
```

**Пояснення:**
1. Ми об'єднуємо таблиці Customers та Orders
2. Групуємо результати за іменем клієнта
3. Умова `HAVING COUNT(DISTINCT ProductID) > 1` відбирає лише тих клієнтів, які замовили більше одного унікального товару

## Задача 4: Вивести всі товари та їхні замовлення, включаючи товари, які ніколи не замовлялися

Ця задача потребує використання RIGHT JOIN, щоб включити товари без замовлень.

```sql
SELECT O.OrderID, P.ProductID, P.ProductName
FROM Orders O
RIGHT JOIN Products P ON O.ProductID = P.ProductID;
```

**Пояснення:**
1. RIGHT JOIN зберігає всі рядки з правої таблиці (Products)
2. Для товарів, які ніколи не замовлялися, OrderID буде NULL

## Задача 5: Отримати всі замовлення, зроблені клієнтами з України

```sql
SELECT O.OrderID
FROM Customers C
INNER JOIN Orders O ON C.CustomerID = O.CustomerID
WHERE C.Country = 'Україна';
```

**Пояснення:**
1. Ми об'єднуємо таблиці Customers та Orders
2. Умова `WHERE C.Country = 'Україна'` фільтрує лише клієнтів з України
3. Повертаємо ідентифікатори замовлень, зроблених цими клієнтами

## Задача 6: Знайти імена клієнтів, які замовили товар з ціною понад 500 гривень

```sql
SELECT DISTINCT C.CustomerName
FROM Customers C
INNER JOIN Orders O ON C.CustomerID = O.CustomerID
INNER JOIN Products P ON O.ProductID = P.ProductID
WHERE P.Price > 500;
```

**Пояснення:**
1. Ми об'єднуємо всі три таблиці
2. Умова `WHERE P.Price > 500` відбирає лише замовлення з дорогими товарами
3. `DISTINCT` видаляє дублікати імен клієнтів (якщо клієнт замовив кілька дорогих товарів)

## Задача 7: Знайти клієнтів, які замовили той самий товар більше одного разу

```sql
SELECT CustomerName
FROM (
    SELECT C.CustomerName, O.ProductID, COUNT(O.OrderID) AS OrderCount
    FROM Customers C
    INNER JOIN Orders O ON C.CustomerID = O.CustomerID
    GROUP BY C.CustomerName, O.ProductID
    HAVING COUNT(O.OrderID) > 1
) M;
```

**Пояснення:**
1. Внутрішній підзапит групує дані за іменем клієнта та ідентифікатором товару
2. Умова `HAVING COUNT(O.OrderID) > 1` відбирає групи, де один і той самий товар був замовлений більше одного разу
3. Основний запит вибирає імена таких клієнтів

## Важливі концепції, розглянуті в лекції

### 1. Самоз'єднання (SELF JOIN)
Самоз'єднання використовується, коли потрібно порівняти рядки в межах однієї таблиці. Для цього:
- Таблиця з'єднується сама з собою з різними аліасами
- Потрібні умови для уникнення порівняння рядка із самим собою
- Часто потрібні додаткові умови для запобігання дублюванню результатів

### 2. Віконні функції
Віконні функції, такі як `DENSE_RANK()`, дозволяють виконувати обчислення над набором рядків, пов'язаних із поточним рядком.
- `DENSE_RANK()` присвоює ранг рядкам без пропусків у послідовності
- Використовується разом із `OVER(ORDER BY...)` для визначення порядку рангування

### 3. Вкладені запити
Вкладені запити дозволяють використовувати результати одного запиту як вхідні дані для іншого.
- Корисні для складних операцій фільтрації та агрегації
- Можуть покращити читабельність складних запитів

### 4. Різні типи JOIN з умовами
- `INNER JOIN` з умовами WHERE для фільтрації результатів
- `RIGHT JOIN` для включення всіх рядків з правої таблиці
- Комбінація кількох JOIN для зв'язування більше двох таблиць

### 5. Групування з умовами HAVING
- `GROUP BY` для групування даних за певними стовпцями
- `HAVING` для фільтрації груп на основі агрегатних функцій
- Комбінація `GROUP BY` та `HAVING` для знаходження складних шаблонів у даних

## Висновок

Розглянули більш складні запити з використанням JOIN і вивчили:
- Як використовувати самоз'єднання для порівняння рядків у межах однієї таблиці
- Як застосовувати віконні функції для рангування результатів
- Як ефективно об'єднувати кілька таблиць для вирішення складних задач
- Як використовувати агрегатні функції з групуванням і умовами HAVING
- Як працювати з вкладеними запитами для більш складної фільтрації

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Знаходження другої найвищої зарплати

Розглянемо важливе питання для співбесід з SQL – як знайти другу найвищу зарплату в таблиці. Це завдання часто зустрічається на технічних інтерв'ю.

## Підготовка бази даних
Спочатку створимо нову базу даних для наших прикладів:

```sql
CREATE DATABASE AdvancedSQLQuestions;
USE AdvancedSQLQuestions;
```

Тепер створимо таблицю `Employees` та заповнимо її даними:

```sql
CREATE TABLE Employees (
    Id INT,
    Name VARCHAR(50),
    Salary INT
);

INSERT INTO Employees VALUES
    (1, 'Співробітник1', 80000),
    (2, 'Співробітник2', 90000),
    (3, 'Співробітник3', 85000),
    (4, 'Співробітник4', 95000),
    (5, 'Співробітник5', 70000),
    (6, 'Співробітник6', 75000),
    (7, 'Співробітник7', 60000),
    (8, 'Співробітник8', 98000),
    (9, 'Співробітник9', 65000),
    (10, 'Співробітник10', 88000);
```

## Метод 1: Використання підзапитів

Перший підхід використовує підзапити. Спочатку знайдемо максимальну зарплату:

```sql
SELECT MAX(Salary) FROM Employees;
```

Тепер модифікуємо запит, щоб знайти другу найвищу зарплату:

```sql
SELECT MAX(Salary) AS [Друга найвища зарплата]
FROM Employees
WHERE Salary < (SELECT MAX(Salary) FROM Employees);
```

Якщо потрібно знайти третю найвищу зарплату:

```sql
SELECT MAX(Salary) AS [Третя найвища зарплата]
FROM Employees
WHERE Salary < (
    SELECT MAX(Salary) 
    FROM Employees 
    WHERE Salary < (SELECT MAX(Salary) FROM Employees)
);
```

## Метод 2: Використання CTE та функції DENSE_RANK()

Другий підхід використовує загальні табличні вирази (CTE) разом із функцією DENSE_RANK():

```sql
WITH CTE AS (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
)
SELECT Salary AS [Друга найвища зарплата]
FROM CTE
WHERE DR = 2;
```

Для третьої найвищої зарплати:

```sql
WITH CTE AS (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
)
SELECT Salary AS [Третя найвища зарплата]
FROM CTE
WHERE DR = 3;
```

## Метод 3: Підзапити з DENSE_RANK()

Третій підхід використовує підзапити з функцією DENSE_RANK():

```sql
SELECT Salary AS [Друга найвища зарплата]
FROM (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
) X
WHERE DR = 2;
```

Для третьої найвищої зарплати:

```sql
SELECT Salary AS [Третя найвища зарплата]
FROM (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
) X
WHERE DR = 3;
```

## Метод 4: Підзапити з TOP

Четвертий підхід використовує підзапити з ключовим словом TOP:

```sql
SELECT TOP 1 Salary AS [Друга найвища зарплата]
FROM (
    SELECT DISTINCT TOP 2 Salary
    FROM Employees
    ORDER BY Salary DESC
) X
ORDER BY Salary ASC;
```

Для третьої найвищої зарплати:

```sql
SELECT TOP 1 Salary AS [Третя найвища зарплата]
FROM (
    SELECT DISTINCT TOP 3 Salary
    FROM Employees
    ORDER BY Salary DESC
) Y
ORDER BY Salary ASC;
```

## Висновок
Ми розглянули чотири різні підходи до знаходження n-ої найвищої зарплати в SQL:
1. Використання підзапитів
2. Використання CTE з DENSE_RANK()
3. Підзапити з DENSE_RANK()
4. Підзапити з TOP

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Використання самоз'єднання (Self Join)

Розглянемо ще одне важливе питання, яке часто зустрічається на співбесідах з SQL – як використовувати самоз'єднання (self join) для роботи з ієрархічними даними.

## Підготовка даних
Спочатку створимо таблицю з даними для нашого прикладу:

```sql
CREATE TABLE ReportingStructure (
    EmployeeID INT,
    EmployeeName VARCHAR(50),
    ManagerID INT
);

INSERT INTO ReportingStructure VALUES
    (1, 'Аліса Сміт', NULL),
    (2, 'Боб Джонсон', 1),
    (3, 'Керол Вайт', 1),
    (4, 'Девід Браун', 2),
    (5, 'Єва Девіс', 2),
    (6, 'Френк Міллер', 3);
```

Давайте подивимось на структуру нашої таблиці:

```sql
SELECT * FROM ReportingStructure;
```

Ця таблиця має три стовпці:
- `EmployeeID` - ідентифікатор співробітника
- `EmployeeName` - ім'я співробітника
- `ManagerID` - ідентифікатор керівника

Зверніть увагу, що у першого співробітника (Аліси Сміт) значення `ManagerID` дорівнює NULL, оскільки вона не підпорядковується жодному керівнику.

## Постановка задачі
Нам потрібно створити звіт, який міститиме два стовпці:
1. Ім'я підлеглого співробітника
2. Ім'я керівника

Тобто, для кожного співробітника ми хочемо бачити, хто є його керівником, включаючи співробітників, які не мають керівників.

## Розв'язання за допомогою самоз'єднання

Для вирішення цієї задачі ми використаємо самоз'єднання (self join). При самоз'єднанні таблиця з'єднується сама з собою, і для цього ми використовуємо псевдоніми (alias).

### Крок 1: Основний запит з самоз'єднанням

```sql
SELECT 
    B.EmployeeName AS [Підлеглий],
    A.EmployeeName AS [Керівник]
FROM 
    ReportingStructure A
INNER JOIN 
    ReportingStructure B
ON 
    A.EmployeeID = B.ManagerID;
```

Що відбувається в цьому запиті:
1. Ми використовуємо таблицю `ReportingStructure` двічі, надаючи їй псевдоніми `A` та `B`
2. Таблиця `A` представляє керівників, а таблиця `B` - підлеглих
3. Умова з'єднання `A.EmployeeID = B.ManagerID` означає, що ми пов'язуємо ID керівника з полем `ManagerID` підлеглого

Результат цього запиту показує всіх підлеглих та їхніх керівників:
- Боб підпорядковується Алісі
- Керол підпорядковується Алісі
- Девід підпорядковується Бобу
- Єва підпорядковується Бобу
- Френк підпорядковується Керол

### Проблема з запитом

Однак, у цьому запиті є проблема: Аліса Сміт не з'являється в результатах, оскільки в неї немає керівника (`ManagerID` = NULL). Внутрішнє з'єднання (INNER JOIN) виключає записи, де умова з'єднання дає NULL.

### Крок 2: Додавання співробітників без керівників

Щоб включити співробітників без керівників, ми використаємо оператор `UNION ALL`:

```sql
SELECT 
    B.EmployeeName AS [Підлеглий],
    A.EmployeeName AS [Керівник]
FROM 
    ReportingStructure A
INNER JOIN 
    ReportingStructure B
ON 
    A.EmployeeID = B.ManagerID

UNION ALL

SELECT 
    EmployeeName AS [Підлеглий],
    NULL AS [Керівник]
FROM 
    ReportingStructure
WHERE 
    ManagerID IS NULL;
```

Цей запит додає до результатів всіх співробітників, у яких `ManagerID` дорівнює NULL, і для них у стовпці [Керівник] буде значення NULL.

## Остаточні результати

Тепер наш запит виводить повну структуру підпорядкування:
- Аліса не має керівника (NULL)
- Боб підпорядковується Алісі
- Керол підпорядковується Алісі
- Девід підпорядковується Бобу
- Єва підпорядковується Бобу
- Френк підпорядковується Керол

## Висновок

Самоз'єднання (self join) — це потужний інструмент для роботи з ієрархічними даними в SQL. Воно дозволяє зв'язувати записи в межах однієї таблиці, що особливо корисно для відображення структур підпорядкування, генеалогічних дерев, або будь-яких інших ієрархічних зв'язків.

Для повноти результатів важливо пам'ятати про обробку NULL-значень, оскільки внутрішнє з'єднання виключає записи з NULL-значеннями в умові з'єднання.

Це питання часто зустрічається на співбесідах з SQL, тому важливо розуміти концепцію самоз'єднання та вміти застосовувати її на практиці.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Видалення дублікатів у таблиці

Розглянемо ще одне важливе питання, яке часто зустрічається на співбесідах з SQL – як видаляти дублікати з таблиці. 
Це завдання регулярно зустрічається в реальних проектах та на технічних інтерв'ю.

## Підготовка даних
Спочатку створимо таблицю з тестовими даними, яка містить дублікати:

```sql
CREATE TABLE EmployeeRecords (
    EmployeeID INT,
    EmployeeName VARCHAR(50),
    ManagerID INT
);

INSERT INTO EmployeeRecords VALUES
    (1, 'Іван Петренко', 101),
    (2, 'Марія Коваленко', 102),
    (2, 'Марія Коваленко', 102), -- дублікат
    (3, 'Олександр Шевченко', 101),
    (4, 'Юлія Мельник', 103),
    (5, 'Андрій Бондаренко', 102),
    (5, 'Андрій Бондаренко', 102), -- дублікат
    (6, 'Оксана Ткаченко', 103);
```

Переглянемо наші дані:

```sql
SELECT * FROM EmployeeRecords
ORDER BY EmployeeID, EmployeeName, ManagerID;
```

Як ми бачимо, у таблиці є дублікати:
- Записи 2 і 3 ідентичні (Марія Коваленко з ManagerID 102)
- Записи 5 і 6 ідентичні (Андрій Бондаренко з ManagerID 102)

Наше завдання - видалити ці дублікати так, щоб для кожного унікального набору значень залишився лише один запис.

## Метод 1: Використання ROW_NUMBER()

Перший підхід використовує віконну функцію ROW_NUMBER() разом із загальним табличним виразом (CTE):

```sql
WITH CTE AS (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY EmployeeID, EmployeeName, ManagerID 
                             ORDER BY EmployeeID) AS RowNumber
    FROM EmployeeRecords
)
DELETE FROM CTE
WHERE RowNumber > 1;
```

Розберемо цей підхід:

1. Спочатку ми створюємо CTE, де для кожного запису додається стовпець `RowNumber`
2. Функція `ROW_NUMBER()` присвоює порядковий номер кожному рядку в межах групи з однаковими значеннями `EmployeeID`, `EmployeeName` та `ManagerID`
3. Потім ми видаляємо всі записи, де `RowNumber` більше 1, тобто залишаємо лише перший запис з кожної групи дублікатів

Після виконання цього запиту в таблиці залишаться тільки унікальні рядки.

### Примітка щодо DENSE_RANK()

Цікаво відзначити, що функція `DENSE_RANK()` не підходить для цієї задачі, оскільки вона надає однаковий ранг усім дублікатам:

```sql
WITH CTE AS (
    SELECT *,
           DENSE_RANK() OVER (PARTITION BY EmployeeID, EmployeeName, ManagerID 
                             ORDER BY EmployeeID) AS DR
    FROM EmployeeRecords
)
SELECT * FROM CTE;
```

У цьому випадку всі унікальні записи матимуть ранг 1, але і всі дублікати також матимуть ранг 1, що не дозволить нам однозначно ідентифікувати дублікати для видалення.

## Метод 2: Використання тимчасової таблиці

Другий підхід полягає у використанні тимчасової таблиці:

1. Спочатку робимо резервну копію таблиці на випадок помилок:

```sql
SELECT * INTO EmpRecords_BCP FROM EmployeeRecords;
```

2. Потім створюємо тимчасову таблицю з унікальними записами:

```sql
SELECT DISTINCT * INTO Hash1 FROM EmpRecords_BCP;
```

3. Очищаємо оригінальну таблицю:

```sql
TRUNCATE TABLE EmpRecords_BCP;
```

4. Вставляємо унікальні записи назад:

```sql
INSERT INTO EmpRecords_BCP
SELECT * FROM Hash1;
```

Перевагою цього методу є його простота та зрозумілість, однак він вимагає додаткового дискового простору для тимчасових таблиць.

## Порівняння методів

| Метод | Переваги | Недоліки |
|-------|----------|----------|
| ROW_NUMBER() | - Не потребує додаткових таблиць<br>- Виконується як одна транзакція | - Складніший синтаксис<br>- Вимагає розуміння віконних функцій |
| Тимчасова таблиця | - Простий синтаксис<br>- Зрозуміла логіка | - Потребує додаткового місця на диску<br>- Кілька запитів замість одного |

## Додаткові міркування

У нашому прикладі ми розглянули випадок, коли дублікатами вважаються записи з ідентичними значеннями у всіх стовпцях. Однак у реальних сценаріях може знадобитися:

1. Видалення дублікатів на основі лише певних стовпців
2. Збереження записів з найбільшим/найменшим значенням у певному стовпці
3. Збереження найновіших/найстаріших записів

У наступній лекції ми розглянемо такі більш складні сценарії видалення дублікатів.

## Висновок

Видалення дублікатів - одне з найпоширеніших завдань в SQL, яке може бути вирішене різними способами. Ми розглянули два ефективних методи:

1. Використання віконної функції ROW_NUMBER() з CTE
2. Використання тимчасової таблиці для зберігання унікальних записів

Обидва методи ефективно видаляють дублікати, а вибір між ними залежить від конкретних вимог проекту та особистих переваг розробника.

Пам'ятайте, що правильне проектування бази даних з відповідними обмеженнями унікальності може запобігти виникненню дублікатів у майбутньому, що є кращим підходом, ніж їх подальше видалення.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#  Видалення часткових дублікатів у таблиці

## Вступ
Вітаю всіх на цій лекції! У попередній лекції ми розглянули видалення повних дублікатів, коли всі стовпці запису дублюються. Сьогодні ми розглянемо більш складний випадок - коли дублікати виникають лише в окремих стовпцях таблиці, а інші значення можуть відрізнятися.

## Підготовка даних
Створимо нову таблицю з тестовими даними для нашого прикладу:

```sql
CREATE TABLE EmployeeRecords_1 (
    EmployeeID INT,
    Email VARCHAR(100)
);

INSERT INTO EmployeeRecords_1 VALUES
    (1, 'ivan@example.com'),
    (2, 'maria@example.com'),
    (2, 'maria@example.com'),        -- повний дублікат
    (3, 'oleksandr@example.com'),
    (4, 'yulia@example.com'),
    (4, 'yulia@example.com'),        -- повний дублікат
    (5, 'shared@example.com'),
    (6, 'shared@example.com');       -- частковий дублікат (та сама email адреса, але різні EmployeeID)
```

Перевіримо наші дані:

```sql
SELECT * FROM EmployeeRecords_1
ORDER BY EmployeeID, Email;
```

У нашій таблиці є два типи дублікатів:
1. Повні дублікати (записи 2-3 та 4-5) - коли всі стовпці ідентичні
2. Часткові дублікати (записи 7-8) - коли однакова електронна адреса використовується для різних співробітників

## Частина 1: Видалення повних дублікатів

Спочатку видалимо повні дублікати, використовуючи метод з попередньої лекції:

```sql
-- Крок 1: Створення тимчасової таблиці з унікальними записами
SELECT DISTINCT * INTO Hash1 FROM EmployeeRecords_1;

-- Крок 2: Очищення оригінальної таблиці
TRUNCATE TABLE EmployeeRecords_1;

-- Крок 3: Повернення унікальних записів в оригінальну таблицю
INSERT INTO EmployeeRecords_1
SELECT * FROM Hash1;
```

Після виконання цього коду у нас залишається 6 записів (без повних дублікатів), але все ще є проблема з частковими дублікатами в email-адресах.

## Частина 2: Видалення часткових дублікатів

Тепер переходимо до складнішої проблеми - часткових дублікатів. Нам потрібно зберегти лише один запис для кожної унікальної електронної адреси.

### Варіант 1: Зберегти запис з меншим EmployeeID

Припустимо, що ми хочемо залишити запис з меншим значенням EmployeeID:

```sql
WITH CTE AS (
    SELECT *,
           DENSE_RANK() OVER (PARTITION BY Email ORDER BY EmployeeID ASC) AS DR
    FROM EmployeeRecords_1
)
DELETE FROM CTE
WHERE DR > 1;
```

Пояснення:
1. Створюємо CTE з додатковим стовпцем DR, який присвоює ранг записам
2. Використовуємо PARTITION BY Email, щоб групувати записи за електронною адресою
3. ORDER BY EmployeeID ASC сортує записи в межах кожної групи за зростанням EmployeeID
4. Видаляємо всі записи, де DR > 1, залишаючи лише перший запис у кожній групі (з найменшим EmployeeID)

Після виконання цього коду запис з EmployeeID = 5 буде збережено, а запис з EmployeeID = 6 буде видалено.

### Варіант 2: Зберегти запис з більшим EmployeeID

А якщо нам потрібно зберегти запис з більшим значенням EmployeeID? Тоді змінимо порядок сортування:

```sql
WITH CTE AS (
    SELECT *,
           DENSE_RANK() OVER (PARTITION BY Email ORDER BY EmployeeID DESC) AS DR
    FROM EmployeeRecords_2
)
DELETE FROM CTE
WHERE DR > 1;
```

Єдина відмінність - ORDER BY EmployeeID DESC замість ORDER BY EmployeeID ASC.

Після виконання цього коду запис з EmployeeID = 6 буде збережено, а запис з EmployeeID = 5 буде видалено.

## Порівняння результатів

Порівняємо результати обох варіантів:

```sql
-- Результат після збереження записів з меншим EmployeeID
SELECT * FROM EmployeeRecords_1
ORDER BY Email;

-- Результат після збереження записів з більшим EmployeeID
SELECT * FROM EmployeeRecords_2
ORDER BY Email;
```

Результати:
- У першій таблиці (EmployeeRecords_1) для email "shared@example.com" збережено запис з EmployeeID = 5
- У другій таблиці (EmployeeRecords_2) для email "shared@example.com" збережено запис з EmployeeID = 6

## Додаткові критерії вибору

У реальних сценаріях вибір, який запис зберегти, може залежати від різних критеріїв:

1. **Найновіший запис** (якщо є стовпець дати):
   ```sql
   ORDER BY CreationDate DESC
   ```

2. **Найстаріший запис**:
   ```sql
   ORDER BY CreationDate ASC
   ```

3. **Запис з найбільшою кількістю заповнених полів** (найменше NULL значень):
   ```sql
   ORDER BY (CASE WHEN Field1 IS NULL THEN 0 ELSE 1 END + 
             CASE WHEN Field2 IS NULL THEN 0 ELSE 1 END + 
             CASE WHEN Field3 IS NULL THEN 0 ELSE 1 END) DESC
   ```

4. **Комбіновані критерії** - спочатку за одним полем, потім за іншим:
   ```sql
   ORDER BY Status DESC, CreationDate DESC
   ```

## Висновок

У цій лекції ми розглянули два типи дублікатів у SQL-таблицях:
1. Повні дублікати - коли всі стовпці запису ідентичні
2. Часткові дублікати - коли дублюються значення лише в деяких стовпцях

Ми вивчили стратегії видалення обох типів дублікатів, використовуючи різні підходи:
- DISTINCT для видалення повних дублікатів
- Віконні функції (DENSE_RANK) з різними критеріями сортування для видалення часткових дублікатів

Вибір стратегії залежить від бізнес-вимог - який саме запис слід зберегти при виявленні дублікатів.

Ці задачі часто зустрічаються на співбесідах з SQL та в реальних проектах, де доводиться очищати та підготовлювати дані для аналізу. Розуміння різних підходів до видалення дублікатів є важливою навичкою для фахівця з баз даних.






