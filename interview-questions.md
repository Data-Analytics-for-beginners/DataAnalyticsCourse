

# 1 Знаходження другої найвищої зарплати

Розглянемо важливе питання для співбесід з SQL – як знайти другу найвищу зарплату в таблиці. Це завдання часто зустрічається на технічних інтерв'ю.

## Підготовка бази даних
Спочатку створимо нову базу даних для наших прикладів:

```sql
CREATE DATABASE AdvancedSQLQuestions;
USE AdvancedSQLQuestions;
```

Тепер створимо таблицю `Employees` та заповнимо її даними:

```sql
CREATE TABLE Employees (
    Id INT,
    Name VARCHAR(50),
    Salary INT
);

INSERT INTO Employees VALUES
    (1, 'Співробітник1', 80000),
    (2, 'Співробітник2', 90000),
    (3, 'Співробітник3', 85000),
    (4, 'Співробітник4', 95000),
    (5, 'Співробітник5', 70000),
    (6, 'Співробітник6', 75000),
    (7, 'Співробітник7', 60000),
    (8, 'Співробітник8', 98000),
    (9, 'Співробітник9', 65000),
    (10, 'Співробітник10', 88000);
```

## Метод 1: Використання підзапитів

Перший підхід використовує підзапити. Спочатку знайдемо максимальну зарплату:

```sql
SELECT MAX(Salary) FROM Employees;
```

Тепер модифікуємо запит, щоб знайти другу найвищу зарплату:

```sql
SELECT MAX(Salary) AS [Друга найвища зарплата]
FROM Employees
WHERE Salary < (SELECT MAX(Salary) FROM Employees);
```

Якщо потрібно знайти третю найвищу зарплату:

```sql
SELECT MAX(Salary) AS [Третя найвища зарплата]
FROM Employees
WHERE Salary < (
    SELECT MAX(Salary) 
    FROM Employees 
    WHERE Salary < (SELECT MAX(Salary) FROM Employees)
);
```

## Метод 2: Використання CTE та функції DENSE_RANK()

Другий підхід використовує загальні табличні вирази (CTE) разом із функцією DENSE_RANK():

```sql
WITH CTE AS (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
)
SELECT Salary AS [Друга найвища зарплата]
FROM CTE
WHERE DR = 2;
```

Для третьої найвищої зарплати:

```sql
WITH CTE AS (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
)
SELECT Salary AS [Третя найвища зарплата]
FROM CTE
WHERE DR = 3;
```

## Метод 3: Підзапити з DENSE_RANK()

Третій підхід використовує підзапити з функцією DENSE_RANK():

```sql
SELECT Salary AS [Друга найвища зарплата]
FROM (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
) X
WHERE DR = 2;
```

Для третьої найвищої зарплати:

```sql
SELECT Salary AS [Третя найвища зарплата]
FROM (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
) X
WHERE DR = 3;
```

## Метод 4: Підзапити з TOP

Четвертий підхід використовує підзапити з ключовим словом TOP:

```sql
SELECT TOP 1 Salary AS [Друга найвища зарплата]
FROM (
    SELECT DISTINCT TOP 2 Salary
    FROM Employees
    ORDER BY Salary DESC
) X
ORDER BY Salary ASC;
```

Для третьої найвищої зарплати:

```sql
SELECT TOP 1 Salary AS [Третя найвища зарплата]
FROM (
    SELECT DISTINCT TOP 3 Salary
    FROM Employees
    ORDER BY Salary DESC
) Y
ORDER BY Salary ASC;
```

## Висновок
Ми розглянули чотири різні підходи до знаходження n-ої найвищої зарплати в SQL:
1. Використання підзапитів
2. Використання CTE з DENSE_RANK()
3. Підзапити з DENSE_RANK()
4. Підзапити з TOP


# 2 Використання самоз'єднання (Self Join)

Розглянемо ще одне важливе питання, яке часто зустрічається на співбесідах з SQL – як використовувати самоз'єднання (self join) для роботи з ієрархічними даними.

## Підготовка даних
Спочатку створимо таблицю з даними для нашого прикладу:

```sql
CREATE TABLE ReportingStructure (
    EmployeeID INT,
    EmployeeName VARCHAR(50),
    ManagerID INT
);

INSERT INTO ReportingStructure VALUES
    (1, 'Аліса Сміт', NULL),
    (2, 'Боб Джонсон', 1),
    (3, 'Керол Вайт', 1),
    (4, 'Девід Браун', 2),
    (5, 'Єва Девіс', 2),
    (6, 'Френк Міллер', 3);
```

Давайте подивимось на структуру нашої таблиці:

```sql
SELECT * FROM ReportingStructure;
```

Ця таблиця має три стовпці:
- `EmployeeID` - ідентифікатор співробітника
- `EmployeeName` - ім'я співробітника
- `ManagerID` - ідентифікатор керівника

Зверніть увагу, що у першого співробітника (Аліси Сміт) значення `ManagerID` дорівнює NULL, оскільки вона не підпорядковується жодному керівнику.

## Постановка задачі
Нам потрібно створити звіт, який міститиме два стовпці:
1. Ім'я підлеглого співробітника
2. Ім'я керівника

Тобто, для кожного співробітника ми хочемо бачити, хто є його керівником, включаючи співробітників, які не мають керівників.

## Розв'язання за допомогою самоз'єднання

Для вирішення цієї задачі ми використаємо самоз'єднання (self join). При самоз'єднанні таблиця з'єднується сама з собою, і для цього ми використовуємо псевдоніми (alias).

### Крок 1: Основний запит з самоз'єднанням

```sql
SELECT 
    B.EmployeeName AS [Підлеглий],
    A.EmployeeName AS [Керівник]
FROM 
    ReportingStructure A
INNER JOIN 
    ReportingStructure B
ON 
    A.EmployeeID = B.ManagerID;
```

Що відбувається в цьому запиті:
1. Ми використовуємо таблицю `ReportingStructure` двічі, надаючи їй псевдоніми `A` та `B`
2. Таблиця `A` представляє керівників, а таблиця `B` - підлеглих
3. Умова з'єднання `A.EmployeeID = B.ManagerID` означає, що ми пов'язуємо ID керівника з полем `ManagerID` підлеглого

Результат цього запиту показує всіх підлеглих та їхніх керівників:
- Боб підпорядковується Алісі
- Керол підпорядковується Алісі
- Девід підпорядковується Бобу
- Єва підпорядковується Бобу
- Френк підпорядковується Керол

### Проблема з запитом

Однак, у цьому запиті є проблема: Аліса Сміт не з'являється в результатах, оскільки в неї немає керівника (`ManagerID` = NULL). Внутрішнє з'єднання (INNER JOIN) виключає записи, де умова з'єднання дає NULL.

### Крок 2: Додавання співробітників без керівників

Щоб включити співробітників без керівників, ми використаємо оператор `UNION ALL`:

```sql
SELECT 
    B.EmployeeName AS [Підлеглий],
    A.EmployeeName AS [Керівник]
FROM 
    ReportingStructure A
INNER JOIN 
    ReportingStructure B
ON 
    A.EmployeeID = B.ManagerID

UNION ALL

SELECT 
    EmployeeName AS [Підлеглий],
    NULL AS [Керівник]
FROM 
    ReportingStructure
WHERE 
    ManagerID IS NULL;
```

Цей запит додає до результатів всіх співробітників, у яких `ManagerID` дорівнює NULL, і для них у стовпці [Керівник] буде значення NULL.

## Остаточні результати

Тепер наш запит виводить повну структуру підпорядкування:
- Аліса не має керівника (NULL)
- Боб підпорядковується Алісі
- Керол підпорядковується Алісі
- Девід підпорядковується Бобу
- Єва підпорядковується Бобу
- Френк підпорядковується Керол

## Висновок

Самоз'єднання (self join) — це потужний інструмент для роботи з ієрархічними даними в SQL. Воно дозволяє зв'язувати записи в межах однієї таблиці, що особливо корисно для відображення структур підпорядкування, генеалогічних дерев, або будь-яких інших ієрархічних зв'язків.

Для повноти результатів важливо пам'ятати про обробку NULL-значень, оскільки внутрішнє з'єднання виключає записи з NULL-значеннями в умові з'єднання.

Це питання часто зустрічається на співбесідах з SQL, тому важливо розуміти концепцію самоз'єднання та вміти застосовувати її на практиці.


# 3 Видалення дублікатів у таблиці

Розглянемо ще одне важливе питання, яке часто зустрічається на співбесідах з SQL – як видаляти дублікати з таблиці. 
Це завдання регулярно зустрічається в реальних проектах та на технічних інтерв'ю.

## Підготовка даних
Спочатку створимо таблицю з тестовими даними, яка містить дублікати:

```sql
CREATE TABLE EmployeeRecords (
    EmployeeID INT,
    EmployeeName VARCHAR(50),
    ManagerID INT
);

INSERT INTO EmployeeRecords VALUES
    (1, 'Іван Петренко', 101),
    (2, 'Марія Коваленко', 102),
    (2, 'Марія Коваленко', 102), -- дублікат
    (3, 'Олександр Шевченко', 101),
    (4, 'Юлія Мельник', 103),
    (5, 'Андрій Бондаренко', 102),
    (5, 'Андрій Бондаренко', 102), -- дублікат
    (6, 'Оксана Ткаченко', 103);
```

Переглянемо наші дані:

```sql
SELECT * FROM EmployeeRecords
ORDER BY EmployeeID, EmployeeName, ManagerID;
```

Як ми бачимо, у таблиці є дублікати:
- Записи 2 і 3 ідентичні (Марія Коваленко з ManagerID 102)
- Записи 5 і 6 ідентичні (Андрій Бондаренко з ManagerID 102)

Наше завдання - видалити ці дублікати так, щоб для кожного унікального набору значень залишився лише один запис.

## Метод 1: Використання ROW_NUMBER()

Перший підхід використовує віконну функцію ROW_NUMBER() разом із загальним табличним виразом (CTE):

```sql
WITH CTE AS (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY EmployeeID, EmployeeName, ManagerID 
                             ORDER BY EmployeeID) AS RowNumber
    FROM EmployeeRecords
)
DELETE FROM CTE
WHERE RowNumber > 1;
```

Розберемо цей підхід:

1. Спочатку ми створюємо CTE, де для кожного запису додається стовпець `RowNumber`
2. Функція `ROW_NUMBER()` присвоює порядковий номер кожному рядку в межах групи з однаковими значеннями `EmployeeID`, `EmployeeName` та `ManagerID`
3. Потім ми видаляємо всі записи, де `RowNumber` більше 1, тобто залишаємо лише перший запис з кожної групи дублікатів

Після виконання цього запиту в таблиці залишаться тільки унікальні рядки.

### Примітка щодо DENSE_RANK()

Цікаво відзначити, що функція `DENSE_RANK()` не підходить для цієї задачі, оскільки вона надає однаковий ранг усім дублікатам:

```sql
WITH CTE AS (
    SELECT *,
           DENSE_RANK() OVER (PARTITION BY EmployeeID, EmployeeName, ManagerID 
                             ORDER BY EmployeeID) AS DR
    FROM EmployeeRecords
)
SELECT * FROM CTE;
```

У цьому випадку всі унікальні записи матимуть ранг 1, але і всі дублікати також матимуть ранг 1, що не дозволить нам однозначно ідентифікувати дублікати для видалення.

## Метод 2: Використання тимчасової таблиці

Другий підхід полягає у використанні тимчасової таблиці:

1. Спочатку робимо резервну копію таблиці на випадок помилок:

```sql
SELECT * INTO EmpRecords_BCP FROM EmployeeRecords;
```

2. Потім створюємо тимчасову таблицю з унікальними записами:

```sql
SELECT DISTINCT * INTO Hash1 FROM EmpRecords_BCP;
```

3. Очищаємо оригінальну таблицю:

```sql
TRUNCATE TABLE EmpRecords_BCP;
```

4. Вставляємо унікальні записи назад:

```sql
INSERT INTO EmpRecords_BCP
SELECT * FROM Hash1;
```

Перевагою цього методу є його простота та зрозумілість, однак він вимагає додаткового дискового простору для тимчасових таблиць.

## Порівняння методів

| Метод | Переваги | Недоліки |
|-------|----------|----------|
| ROW_NUMBER() | - Не потребує додаткових таблиць<br>- Виконується як одна транзакція | - Складніший синтаксис<br>- Вимагає розуміння віконних функцій |
| Тимчасова таблиця | - Простий синтаксис<br>- Зрозуміла логіка | - Потребує додаткового місця на диску<br>- Кілька запитів замість одного |

## Додаткові міркування

У нашому прикладі ми розглянули випадок, коли дублікатами вважаються записи з ідентичними значеннями у всіх стовпцях. Однак у реальних сценаріях може знадобитися:

1. Видалення дублікатів на основі лише певних стовпців
2. Збереження записів з найбільшим/найменшим значенням у певному стовпці
3. Збереження найновіших/найстаріших записів

У наступній лекції ми розглянемо такі більш складні сценарії видалення дублікатів.

## Висновок

Видалення дублікатів - одне з найпоширеніших завдань в SQL, яке може бути вирішене різними способами. Ми розглянули два ефективних методи:

1. Використання віконної функції ROW_NUMBER() з CTE
2. Використання тимчасової таблиці для зберігання унікальних записів

Обидва методи ефективно видаляють дублікати, а вибір між ними залежить від конкретних вимог проекту та особистих переваг розробника.

Пам'ятайте, що правильне проектування бази даних з відповідними обмеженнями унікальності може запобігти виникненню дублікатів у майбутньому, що є кращим підходом, ніж їх подальше видалення.


# 4 Видалення часткових дублікатів у таблиці

## Вступ
Вітаю всіх на цій лекції! У попередній лекції ми розглянули видалення повних дублікатів, коли всі стовпці запису дублюються. Сьогодні ми розглянемо більш складний випадок - коли дублікати виникають лише в окремих стовпцях таблиці, а інші значення можуть відрізнятися.

## Підготовка даних
Створимо нову таблицю з тестовими даними для нашого прикладу:

```sql
CREATE TABLE EmployeeRecords_1 (
    EmployeeID INT,
    Email VARCHAR(100)
);

INSERT INTO EmployeeRecords_1 VALUES
    (1, 'ivan@example.com'),
    (2, 'maria@example.com'),
    (2, 'maria@example.com'),        -- повний дублікат
    (3, 'oleksandr@example.com'),
    (4, 'yulia@example.com'),
    (4, 'yulia@example.com'),        -- повний дублікат
    (5, 'shared@example.com'),
    (6, 'shared@example.com');       -- частковий дублікат (та сама email адреса, але різні EmployeeID)
```

Перевіримо наші дані:

```sql
SELECT * FROM EmployeeRecords_1
ORDER BY EmployeeID, Email;
```

У нашій таблиці є два типи дублікатів:
1. Повні дублікати (записи 2-3 та 4-5) - коли всі стовпці ідентичні
2. Часткові дублікати (записи 7-8) - коли однакова електронна адреса використовується для різних співробітників

## Частина 1: Видалення повних дублікатів

Спочатку видалимо повні дублікати, використовуючи метод з попередньої лекції:

```sql
-- Крок 1: Створення тимчасової таблиці з унікальними записами
SELECT DISTINCT * INTO Hash1 FROM EmployeeRecords_1;

-- Крок 2: Очищення оригінальної таблиці
TRUNCATE TABLE EmployeeRecords_1;

-- Крок 3: Повернення унікальних записів в оригінальну таблицю
INSERT INTO EmployeeRecords_1
SELECT * FROM Hash1;
```

Після виконання цього коду у нас залишається 6 записів (без повних дублікатів), але все ще є проблема з частковими дублікатами в email-адресах.

## Частина 2: Видалення часткових дублікатів

Тепер переходимо до складнішої проблеми - часткових дублікатів. Нам потрібно зберегти лише один запис для кожної унікальної електронної адреси.

### Варіант 1: Зберегти запис з меншим EmployeeID

Припустимо, що ми хочемо залишити запис з меншим значенням EmployeeID:

```sql
WITH CTE AS (
    SELECT *,
           DENSE_RANK() OVER (PARTITION BY Email ORDER BY EmployeeID ASC) AS DR
    FROM EmployeeRecords_1
)
DELETE FROM CTE
WHERE DR > 1;
```

Пояснення:
1. Створюємо CTE з додатковим стовпцем DR, який присвоює ранг записам
2. Використовуємо PARTITION BY Email, щоб групувати записи за електронною адресою
3. ORDER BY EmployeeID ASC сортує записи в межах кожної групи за зростанням EmployeeID
4. Видаляємо всі записи, де DR > 1, залишаючи лише перший запис у кожній групі (з найменшим EmployeeID)

Після виконання цього коду запис з EmployeeID = 5 буде збережено, а запис з EmployeeID = 6 буде видалено.

### Варіант 2: Зберегти запис з більшим EmployeeID

А якщо нам потрібно зберегти запис з більшим значенням EmployeeID? Тоді змінимо порядок сортування:

```sql
WITH CTE AS (
    SELECT *,
           DENSE_RANK() OVER (PARTITION BY Email ORDER BY EmployeeID DESC) AS DR
    FROM EmployeeRecords_2
)
DELETE FROM CTE
WHERE DR > 1;
```

Єдина відмінність - ORDER BY EmployeeID DESC замість ORDER BY EmployeeID ASC.

Після виконання цього коду запис з EmployeeID = 6 буде збережено, а запис з EmployeeID = 5 буде видалено.

## Порівняння результатів

Порівняємо результати обох варіантів:

```sql
-- Результат після збереження записів з меншим EmployeeID
SELECT * FROM EmployeeRecords_1
ORDER BY Email;

-- Результат після збереження записів з більшим EmployeeID
SELECT * FROM EmployeeRecords_2
ORDER BY Email;
```

Результати:
- У першій таблиці (EmployeeRecords_1) для email "shared@example.com" збережено запис з EmployeeID = 5
- У другій таблиці (EmployeeRecords_2) для email "shared@example.com" збережено запис з EmployeeID = 6

## Додаткові критерії вибору

У реальних сценаріях вибір, який запис зберегти, може залежати від різних критеріїв:

1. **Найновіший запис** (якщо є стовпець дати):
   ```sql
   ORDER BY CreationDate DESC
   ```

2. **Найстаріший запис**:
   ```sql
   ORDER BY CreationDate ASC
   ```

3. **Запис з найбільшою кількістю заповнених полів** (найменше NULL значень):
   ```sql
   ORDER BY (CASE WHEN Field1 IS NULL THEN 0 ELSE 1 END + 
             CASE WHEN Field2 IS NULL THEN 0 ELSE 1 END + 
             CASE WHEN Field3 IS NULL THEN 0 ELSE 1 END) DESC
   ```

4. **Комбіновані критерії** - спочатку за одним полем, потім за іншим:
   ```sql
   ORDER BY Status DESC, CreationDate DESC
   ```

## Висновок

У цій лекції ми розглянули два типи дублікатів у SQL-таблицях:
1. Повні дублікати - коли всі стовпці запису ідентичні
2. Часткові дублікати - коли дублюються значення лише в деяких стовпцях

Ми вивчили стратегії видалення обох типів дублікатів, використовуючи різні підходи:
- DISTINCT для видалення повних дублікатів
- Віконні функції (DENSE_RANK) з різними критеріями сортування для видалення часткових дублікатів

Вибір стратегії залежить від бізнес-вимог - який саме запис слід зберегти при виявленні дублікатів.

Ці задачі часто зустрічаються на співбесідах з SQL та в реальних проектах, де доводиться очищати та підготовлювати дані для аналізу. Розуміння різних підходів до видалення дублікатів є важливою навичкою для фахівця з баз даних.






