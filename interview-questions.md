

# Знаходження другої найвищої зарплати

Розглянемо важливе питання для співбесід з SQL – як знайти другу найвищу зарплату в таблиці. Це завдання часто зустрічається на технічних інтерв'ю.

## Підготовка бази даних
Спочатку створимо нову базу даних для наших прикладів:

```sql
CREATE DATABASE AdvancedSQLQuestions;
USE AdvancedSQLQuestions;
```

Тепер створимо таблицю `Employees` та заповнимо її даними:

```sql
CREATE TABLE Employees (
    Id INT,
    Name VARCHAR(50),
    Salary INT
);

INSERT INTO Employees VALUES
    (1, 'Співробітник1', 80000),
    (2, 'Співробітник2', 90000),
    (3, 'Співробітник3', 85000),
    (4, 'Співробітник4', 95000),
    (5, 'Співробітник5', 70000),
    (6, 'Співробітник6', 75000),
    (7, 'Співробітник7', 60000),
    (8, 'Співробітник8', 98000),
    (9, 'Співробітник9', 65000),
    (10, 'Співробітник10', 88000);
```

## Метод 1: Використання підзапитів

Перший підхід використовує підзапити. Спочатку знайдемо максимальну зарплату:

```sql
SELECT MAX(Salary) FROM Employees;
```

Тепер модифікуємо запит, щоб знайти другу найвищу зарплату:

```sql
SELECT MAX(Salary) AS [Друга найвища зарплата]
FROM Employees
WHERE Salary < (SELECT MAX(Salary) FROM Employees);
```

Якщо потрібно знайти третю найвищу зарплату:

```sql
SELECT MAX(Salary) AS [Третя найвища зарплата]
FROM Employees
WHERE Salary < (
    SELECT MAX(Salary) 
    FROM Employees 
    WHERE Salary < (SELECT MAX(Salary) FROM Employees)
);
```

## Метод 2: Використання CTE та функції DENSE_RANK()

Другий підхід використовує загальні табличні вирази (CTE) разом із функцією DENSE_RANK():

```sql
WITH CTE AS (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
)
SELECT Salary AS [Друга найвища зарплата]
FROM CTE
WHERE DR = 2;
```

Для третьої найвищої зарплати:

```sql
WITH CTE AS (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
)
SELECT Salary AS [Третя найвища зарплата]
FROM CTE
WHERE DR = 3;
```

## Метод 3: Підзапити з DENSE_RANK()

Третій підхід використовує підзапити з функцією DENSE_RANK():

```sql
SELECT Salary AS [Друга найвища зарплата]
FROM (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
) X
WHERE DR = 2;
```

Для третьої найвищої зарплати:

```sql
SELECT Salary AS [Третя найвища зарплата]
FROM (
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employees
) X
WHERE DR = 3;
```

## Метод 4: Підзапити з TOP

Четвертий підхід використовує підзапити з ключовим словом TOP:

```sql
SELECT TOP 1 Salary AS [Друга найвища зарплата]
FROM (
    SELECT DISTINCT TOP 2 Salary
    FROM Employees
    ORDER BY Salary DESC
) X
ORDER BY Salary ASC;
```

Для третьої найвищої зарплати:

```sql
SELECT TOP 1 Salary AS [Третя найвища зарплата]
FROM (
    SELECT DISTINCT TOP 3 Salary
    FROM Employees
    ORDER BY Salary DESC
) Y
ORDER BY Salary ASC;
```

## Висновок
Ми розглянули чотири різні підходи до знаходження n-ої найвищої зарплати в SQL:
1. Використання підзапитів
2. Використання CTE з DENSE_RANK()
3. Підзапити з DENSE_RANK()
4. Підзапити з TOP


# Використання самоз'єднання (Self Join)

Розглянемо ще одне важливе питання, яке часто зустрічається на співбесідах з SQL – як використовувати самоз'єднання (self join) для роботи з ієрархічними даними.

## Підготовка даних
Спочатку створимо таблицю з даними для нашого прикладу:

```sql
CREATE TABLE ReportingStructure (
    EmployeeID INT,
    EmployeeName VARCHAR(50),
    ManagerID INT
);

INSERT INTO ReportingStructure VALUES
    (1, 'Аліса Сміт', NULL),
    (2, 'Боб Джонсон', 1),
    (3, 'Керол Вайт', 1),
    (4, 'Девід Браун', 2),
    (5, 'Єва Девіс', 2),
    (6, 'Френк Міллер', 3);
```

Давайте подивимось на структуру нашої таблиці:

```sql
SELECT * FROM ReportingStructure;
```

Ця таблиця має три стовпці:
- `EmployeeID` - ідентифікатор співробітника
- `EmployeeName` - ім'я співробітника
- `ManagerID` - ідентифікатор керівника

Зверніть увагу, що у першого співробітника (Аліси Сміт) значення `ManagerID` дорівнює NULL, оскільки вона не підпорядковується жодному керівнику.

## Постановка задачі
Нам потрібно створити звіт, який міститиме два стовпці:
1. Ім'я підлеглого співробітника
2. Ім'я керівника

Тобто, для кожного співробітника ми хочемо бачити, хто є його керівником, включаючи співробітників, які не мають керівників.

## Розв'язання за допомогою самоз'єднання

Для вирішення цієї задачі ми використаємо самоз'єднання (self join). При самоз'єднанні таблиця з'єднується сама з собою, і для цього ми використовуємо псевдоніми (alias).

### Крок 1: Основний запит з самоз'єднанням

```sql
SELECT 
    B.EmployeeName AS [Підлеглий],
    A.EmployeeName AS [Керівник]
FROM 
    ReportingStructure A
INNER JOIN 
    ReportingStructure B
ON 
    A.EmployeeID = B.ManagerID;
```

Що відбувається в цьому запиті:
1. Ми використовуємо таблицю `ReportingStructure` двічі, надаючи їй псевдоніми `A` та `B`
2. Таблиця `A` представляє керівників, а таблиця `B` - підлеглих
3. Умова з'єднання `A.EmployeeID = B.ManagerID` означає, що ми пов'язуємо ID керівника з полем `ManagerID` підлеглого

Результат цього запиту показує всіх підлеглих та їхніх керівників:
- Боб підпорядковується Алісі
- Керол підпорядковується Алісі
- Девід підпорядковується Бобу
- Єва підпорядковується Бобу
- Френк підпорядковується Керол

### Проблема з запитом

Однак, у цьому запиті є проблема: Аліса Сміт не з'являється в результатах, оскільки в неї немає керівника (`ManagerID` = NULL). Внутрішнє з'єднання (INNER JOIN) виключає записи, де умова з'єднання дає NULL.

### Крок 2: Додавання співробітників без керівників

Щоб включити співробітників без керівників, ми використаємо оператор `UNION ALL`:

```sql
SELECT 
    B.EmployeeName AS [Підлеглий],
    A.EmployeeName AS [Керівник]
FROM 
    ReportingStructure A
INNER JOIN 
    ReportingStructure B
ON 
    A.EmployeeID = B.ManagerID

UNION ALL

SELECT 
    EmployeeName AS [Підлеглий],
    NULL AS [Керівник]
FROM 
    ReportingStructure
WHERE 
    ManagerID IS NULL;
```

Цей запит додає до результатів всіх співробітників, у яких `ManagerID` дорівнює NULL, і для них у стовпці [Керівник] буде значення NULL.

## Остаточні результати

Тепер наш запит виводить повну структуру підпорядкування:
- Аліса не має керівника (NULL)
- Боб підпорядковується Алісі
- Керол підпорядковується Алісі
- Девід підпорядковується Бобу
- Єва підпорядковується Бобу
- Френк підпорядковується Керол

## Висновок

Самоз'єднання (self join) — це потужний інструмент для роботи з ієрархічними даними в SQL. Воно дозволяє зв'язувати записи в межах однієї таблиці, що особливо корисно для відображення структур підпорядкування, генеалогічних дерев, або будь-яких інших ієрархічних зв'язків.

Для повноти результатів важливо пам'ятати про обробку NULL-значень, оскільки внутрішнє з'єднання виключає записи з NULL-значеннями в умові з'єднання.

Це питання часто зустрічається на співбесідах з SQL, тому важливо розуміти концепцію самоз'єднання та вміти застосовувати її на практиці.


