

# Зміст 

## Віконні функції в SQL

### 1. Віконні функції: RANK, DENSE_RANK та ROW_NUMBER
- [Вступ до віконних функцій](#віконні-функції-rank-dense_rank-та-row_number)
- [Підготовка даних](#підготовка-даних)
- [Функція ROW_NUMBER()](#функція-row_number)
- [Функція RANK()](#функція-rank)
- [Функція DENSE_RANK()](#функція-dense_rank)
- [Порівняння функцій](#порівняння-функцій)

### 2. Віконні функції з PARTITION BY
- [Розширення функцій ROW_NUMBER, RANK та DENSE_RANK](#віконні-функції-в-sql-з-використанням-partition-by)
- [Використання PARTITION BY з різними функціями](#використання-partition-by-з-різними-функціями)

### 3. Функція LEAD в SQL
- [Вступ до функції LEAD](#віконна-функція-lead-в-sql)
- [Використання функції для аналізу даних](#використання-функції-lead-для-отримання-прибутку-за-наступний-місяць)

### 4. Функція LAG в SQL
- [Вступ до функції LAG](#віконна-функція-lag-в-sql)
- [Використання функції для аналізу даних](#використання-функції-lag-для-отримання-прибутку-за-попередній-місяць)

## Функції обробки NULL-значень

### 5. Функції ISNULL та COALESCE
- [Вступ до функцій обробки NULL-значень](#функції-isnull-та-coalesce-в-sql)
- [Функція ISNULL](#функція-isnull)
- [Функція COALESCE](#функція-coalesce)
- [Практичне застосування](#практичне-застосування)

### 6. Функція FIRST_VALUE
- [Вступ до функції FIRST_VALUE](#віконна-функція-first_value-в-sql)
- [Базове використання](#базове-використання-first_value)
- [Використання з PARTITION BY](#використання-first_value-з-partition-by)

### 7. Функція LAST_VALUE
- [Вступ до функції LAST_VALUE](#віконна-функція-last_value-в-sql)
- [Важливість конструкції ROWS BETWEEN](#важливість-конструкції-rows-between)
- [Використання з різними параметрами](#використання-last_value-з-partition-by)

## Розширені SQL-концепції

### 8. Загальні табличні вирази (CTE)
- [Вступ до CTE](#загальні-табличні-вирази-common-table-expressions-cte-в-sql)
- [Створення та використання CTE](#приклади-використання-cte)

### 9. Множинні CTE
- [Використання кількох CTE](#множинні-загальні-табличні-вирази-multiple-ctes-в-sql)
- [Приклади створення множинних CTE](#приклад-1-визначення-кількох-cte-з-одним-with)

### 10. Рекурсивні CTE
- [Вступ до рекурсивних CTE](#рекурсивні-загальні-табличні-вирази-recursive-cte-в-sql)
- [Структура рекурсивного CTE](#структура-рекурсивного-cte)
- [Приклади використання](#приклад-обчислення-послідовності-чисел)

### 11. Збережені процедури
- [Вступ до збережених процедур](#збережені-процедури-stored-procedures-в-sql)
- [Створення та виклик процедур](#створення-збереженої-процедури)
- [Модифікація процедур](#зміна-існуючої-процедури)

### 12. Представлення (Views)
- [Вступ до представлень](#представлення-views-в-sql)
- [Створення представлень](#створення-представлення)
- [Оновлення даних через представлення](#оновлення-даних-через-представлення)

### 13. Індекси
- [Вступ до індексів](#індекси-в-microsoft-sql-server)
- [Створення індексів](#створення-індексу)
- [Типи індексів](#типи-індексів)

### 14. Кластеризовані індекси
- [Вступ до кластеризованих індексів](#кластеризовані-індекси-в-sql-server)
- [Створення кластеризованого індексу](#створення-кластеризованого-індексу)
- [Особливості кластеризованих індексів](#важливі-особливості-кластеризованих-індексів)

### 15. Некластеризовані індекси
- [Вступ до некластеризованих індексів](#некластеризовані-індекси-в-sql-server)
- [Створення некластеризованого індексу](#створення-некластеризованого-індексу)
- [Відмінності від кластеризованих індексів](#ключові-відмінності-від-кластеризованих-індексів)





# SQL Functions

# Віконні функції в SQL: RANK, DENSE_RANK та ROW_NUMBER

## Вступ до віконних функцій

Віконні функції в SQL дозволяють виконувати обчислення над набором рядків, який пов'язаний із поточним рядком. У цій лекції ми розглянемо три важливі віконні функції: RANK, DENSE_RANK та ROW_NUMBER.

## Підготовка даних

Для наших прикладів використаємо таблицю `students`. Ви можете знайти код для створення цієї таблиці в ресурсах до лекції.

Спочатку переглянемо дані:

```sql
SELECT * FROM students;
```

## Функція ROW_NUMBER()

Функція ROW_NUMBER() присвоює унікальний порядковий номер кожному рядку в результаті запиту.

```sql
SELECT *,
    ROW_NUMBER() OVER (ORDER BY marks DESC) AS [Row Number]
FROM students;
```

**Особливості ROW_NUMBER():**
- Завжди присвоює унікальний номер кожному рядку
- У випадку однакових значень (наприклад, однакові оцінки) номери присвоюються випадковим чином
- Номери йдуть послідовно без пропусків (1, 2, 3, 4, ...)

## Функція RANK()

Функція RANK() присвоює ранг кожному рядку в результаті запиту.

```sql
SELECT *,
    RANK() OVER (ORDER BY marks DESC) AS [Rank Function]
FROM students;
```

**Особливості RANK():**
- Рядки з однаковими значеннями отримують однаковий ранг
- Якщо є кілька рядків з однаковим рангом, наступний ранг пропускається
- Наприклад: 1, 1, 3, 4, 4, 4, 7, ...

## Функція DENSE_RANK()

Функція DENSE_RANK() також присвоює ранг кожному рядку, але без пропусків.

```sql
SELECT *,
    DENSE_RANK() OVER (ORDER BY marks DESC) AS [Dense Rank]
FROM students;
```

**Особливості DENSE_RANK():**
- Рядки з однаковими значеннями отримують однаковий ранг
- Наступний ранг не пропускається, навіть якщо попередній ранг був присвоєний кільком рядкам
- Наприклад: 1, 1, 2, 3, 3, 3, 4, ...

## Порівняння функцій

### Ключові відмінності:

1. **ROW_NUMBER()**:
   - Завжди унікальний для кожного рядка
   - При однакових значеннях присвоюється випадково

2. **RANK()**:
   - Однакові значення отримують однаковий ранг
   - Пропускає наступні ранги при рівності

3. **DENSE_RANK()**:
   - Однакові значення отримують однаковий ранг
   - Не пропускає ранги

## Сортування за зростанням

Ми також можемо використовувати ці функції для сортування значень за зростанням:

```sql
SELECT *,
    ROW_NUMBER() OVER (ORDER BY marks) AS [Row Number],
    RANK() OVER (ORDER BY marks) AS [Rank Function],
    DENSE_RANK() OVER (ORDER BY marks) AS [Dense Rank]
FROM students;
```

У цьому випадку:
- Найнижчі оцінки отримають найнижчі ранги (1, 2, 3...)
- Найвищі оцінки отримають найвищі ранги

Зверніть увагу, що ключове слово ASC (ascending) є необов'язковим, оскільки сортування за зростанням використовується за замовчуванням.

## Висновок

Віконні функції RANK, DENSE_RANK та ROW_NUMBER є потужними інструментами для аналізу даних в SQL. Вони часто використовуються в аналітичних запитах та є популярними питаннями на співбесідах. У наступній лекції ми розглянемо використання цих функцій разом із конструкцією PARTITION BY для ще більш складного аналізу даних.


# Віконні функції в SQL з використанням PARTITION BY

## Розширення функцій ROW_NUMBER, RANK та DENSE_RANK

У попередній лекції ми розглянули основи віконних функцій ROW_NUMBER, RANK та DENSE_RANK. Сьогодні розглянемо більш складні приклади з використанням конструкції PARTITION BY для створення "вікон" даних.

## Використання PARTITION BY з функцією ROW_NUMBER()

Часто нам потрібно нумерувати рядки не лише за всією таблицею, а й окремо для певних груп даних. Саме для цього використовується PARTITION BY.

### Нумерація за предметами

Створимо запит, який призначає порядкові номери для кожного предмета окремо:

```sql
SELECT *,
    ROW_NUMBER() OVER (PARTITION BY subject ORDER BY marks DESC) AS [Row Number DESC]
FROM students;
```

Результат:
- Для кожного предмета (English, Mathematics, Science) окремо призначаються номери, починаючи з 1
- Найвищі оцінки отримують найменші номери в межах кожного предмета
- Коли починається новий предмет, нумерація починається знову з 1

Якщо хочемо сортувати за зростанням (найнижчі оцінки отримують найменші номери):

```sql
SELECT *,
    ROW_NUMBER() OVER (PARTITION BY subject ORDER BY marks) AS [Row Number ASC]
FROM students;
```

### Нумерація за студентами

Можна також створити вікна за іменами студентів:

```sql
SELECT *,
    ROW_NUMBER() OVER (PARTITION BY student_name ORDER BY marks DESC) AS [Row Number DESC]
FROM students;
```

Результат:
- Для кожного студента (Alice, Bob, Charlie, тощо) окремо призначаються номери
- Предмет з найвищою оцінкою отримує номер 1, далі за спаданням

## Використання PARTITION BY з функцією RANK()

Функцію RANK() також можна використовувати з PARTITION BY:

```sql
SELECT *,
    RANK() OVER (PARTITION BY student_name ORDER BY marks DESC) AS [Rank Descending]
FROM students;
```

Для кожного студента призначаються ранги за оцінками. Нагадаємо, що RANK() пропускає наступні ранги при рівності значень.

Можна також групувати за предметами:

```sql
SELECT *,
    RANK() OVER (PARTITION BY subject ORDER BY marks DESC) AS [Rank Descending]
FROM students;
```

Розглянемо приклад з математики:
- Для двох студентів з оцінкою 90 призначено ранг 2
- Наступна оцінка 85 отримує ранг 4 (ранг 3 пропущено)
- Трьом студентам з оцінкою 85 призначено однаковий ранг 4
- Наступна оцінка отримує ранг 7 (ранги 5 та 6 пропущено)

## Використання PARTITION BY з функцією DENSE_RANK()

Аналогічно можна використовувати DENSE_RANK() з PARTITION BY:

```sql
SELECT *,
    DENSE_RANK() OVER (PARTITION BY subject ORDER BY marks DESC) AS [Dense Rank Descending]
FROM students;
```

Ключова відмінність DENSE_RANK() — відсутність пропусків у рангах:
- Для двох студентів з оцінкою 90 з математики призначено ранг 2
- Наступна оцінка 85 отримує ранг 3 (без пропусків)
- Трьом студентам з оцінкою 85 призначено однаковий ранг 3
- Наступна оцінка отримує ранг 4 (без пропусків)

Можна також групувати за студентами:

```sql
SELECT *,
    DENSE_RANK() OVER (PARTITION BY student_name ORDER BY marks) AS [Dense Rank Ascending]
FROM students;
```

У цьому випадку для кожного студента найнижча оцінка отримує ранг 1.

## Висновок

Віконні функції з PARTITION BY надають потужні можливості для аналізу даних:
- ROW_NUMBER() завжди призначає унікальні номери в межах кожного вікна
- RANK() призначає однакові ранги при рівності, але пропускає наступні ранги
- DENSE_RANK() призначає однакові ранги при рівності без пропусків

Ці функції широко використовуються в аналітичних запитах та часто зустрічаються на технічних співбесідах із SQL.




# Віконна функція LEAD в SQL

## Вступ до віконної функції LEAD

Віконна функція LEAD дозволяє отримати доступ до даних з наступного рядка в результаті запиту без використання самоз'єднання. Ця функція особливо корисна для порівняння значень поточного рядка зі значеннями наступного рядка.

## Підготовка середовища для прикладів

Для наших прикладів створимо нову базу даних та таблицю:

```sql
CREATE DATABASE [profit_db];
USE [profit_db];

CREATE TABLE profit_data (
    month_number INT,
    month_name VARCHAR(20),
    product VARCHAR(10),
    profit INT
);

-- Вставка тестових даних
INSERT INTO profit_data VALUES
(1, 'January', 'Product A', 1200),
(2, 'February', 'Product A', 1500),
(3, 'March', 'Product A', 1200),
(4, 'April', 'Product A', 2200),
(5, 'May', 'Product A', 2800),
(6, 'June', 'Product A', 2100),
(1, 'January', 'Product B', 1800),
(2, 'February', 'Product B', 2500),
(3, 'March', 'Product B', 2200),
(4, 'April', 'Product B', 2200),
(5, 'May', 'Product B', 2800),
(6, 'June', 'Product B', 2100);
```

## Використання функції LEAD для отримання прибутку за наступний місяць

### Приклад 1: Показати прибуток за наступний місяць для кожного продукту

```sql
SELECT *,
    LEAD(profit) OVER (PARTITION BY product ORDER BY month_number) AS [Next Month's Profit]
FROM profit_data;
```

У цьому запиті:
- `LEAD(profit)` отримує значення стовпця profit з наступного рядка
- `PARTITION BY product` створює окремі вікна для кожного продукту
- `ORDER BY month_number` вказує порядок рядків у кожному вікні

### Аналіз результатів:

- Для Product A, січень: прибуток = 1200, прибуток за наступний місяць = 1500
- Для Product A, лютий: прибуток = 1500, прибуток за наступний місяць = 1200
- Для Product A, червень: прибуток = 2100, прибуток за наступний місяць = NULL (оскільки даних за липень немає)

Аналогічно для Product B.

## Складніший приклад: Загальний прибуток за місяць

### Вимога:
Показати загальний прибуток за кожен місяць (без розбивки за продуктами) та прибуток за наступний місяць.

### Крок 1: Спочатку отримаємо загальний прибуток за місяць:

```sql
SELECT 
    month_number, 
    month_name, 
    SUM(profit) AS [Total Profit]
FROM profit_data
GROUP BY month_number, month_name
ORDER BY month_number;
```

### Крок 2: Додамо функцію LEAD для отримання прибутку за наступний місяць:

```sql
SELECT 
    month_number, 
    month_name, 
    SUM(profit) AS [Total Profit],
    LEAD(SUM(profit)) OVER (ORDER BY month_number) AS [Next Month's Total Profit]
FROM profit_data
GROUP BY month_number, month_name
ORDER BY month_number;
```

### Аналіз результатів:

- Січень: загальний прибуток = 3000, прибуток за наступний місяць = 4000
- Лютий: загальний прибуток = 4000, прибуток за наступний місяць = 3400
- Червень: загальний прибуток = 4200, прибуток за наступний місяць = NULL (оскільки даних за липень немає)

## Важливі особливості функції LEAD

1. **Синтаксис**:
   ```sql
   LEAD(column_name [, offset [, default_value]]) OVER ([PARTITION BY partition_expression] ORDER BY sort_expression)
   ```
   
   - `column_name`: стовпець, значення з якого потрібно отримати
   - `offset`: на скільки рядків вперед потрібно заглянути (за замовчуванням 1)
   - `default_value`: значення, яке повертається, якщо немає наступного рядка (за замовчуванням NULL)

2. **NULL для останнього рядка**: для останнього рядка у вікні (або в усьому наборі даних) функція LEAD повертає NULL, якщо не вказано default_value.

3. **Використання з агрегатними функціями**: як показано в другому прикладі, LEAD можна використовувати з агрегатними функціями, такими як SUM.

## Висновок

Віконна функція LEAD є потужним інструментом для аналізу даних в SQL, особливо коли потрібно порівнювати поточні значення з майбутніми. Ця функція часто використовується для:
- Аналізу тенденцій
- Розрахунку змін між періодами
- Прогнозування на основі історичних даних

У наступній лекції ми розглянемо функцію LAG, яка працює аналогічно до LEAD, але отримує значення з попереднього рядка замість наступного.


# Віконна функція LAG в SQL

## Вступ до функції LAG

Віконна функція LAG дозволяє отримати доступ до даних з попереднього рядка в результаті запиту без використання самоз'єднання. На відміну від функції LEAD, яку ми розглянули в попередній лекції і яка отримує дані з наступного рядка, функція LAG дозволяє отримати дані з попереднього рядка.

## Використання таблиці profit_data

Ми продовжимо використовувати таблицю `profit_data`, яку створили в попередній лекції. Спочатку переглянемо дані:

```sql
SELECT * FROM profit_data;
```

Ця таблиця містить такі дані:
- `month_number`: номер місяця
- `month_name`: назва місяця
- `product`: назва продукту
- `profit`: прибуток за місяць для певного продукту

## Використання функції LAG для отримання прибутку за попередній місяць

### Приклад 1: Показати прибуток за попередній місяць для кожного продукту

```sql
SELECT *,
    LAG(profit) OVER (PARTITION BY product ORDER BY month_number) AS [Lag Function]
FROM profit_data;
```

У цьому запиті:
- `LAG(profit)`: отримує значення стовпця profit з попереднього рядка
- `PARTITION BY product`: створює окремі вікна для кожного продукту
- `ORDER BY month_number`: вказує порядок рядків у кожному вікні

### Аналіз результатів:

- Для першого запису (Product A, January): немає попереднього місяця, тому значення NULL
- Для другого запису (Product A, February): прибуток за попередній місяць (January) = 1000
- Для третього запису (Product A, March): прибуток за попередній місяць (February) = 1500

Аналогічна логіка застосовується для Product B.

## Складніший приклад: Загальний прибуток за місяць

### Вимога:
Показати загальний прибуток за кожен місяць (без розбивки за продуктами) та прибуток за попередній місяць.

### Крок 1: Спочатку отримаємо загальний прибуток за місяць:

```sql
SELECT 
    month_number, 
    month_name, 
    SUM(profit) AS [Total Profit For Month]
FROM profit_data
GROUP BY month_number, month_name
ORDER BY month_number;
```

### Крок 2: Додамо функцію LAG для отримання прибутку за попередній місяць:

```sql
SELECT 
    month_number, 
    month_name, 
    SUM(profit) AS [Total Profit For Month],
    LAG(SUM(profit)) OVER (ORDER BY month_number) AS [Previous Month's Total Profit]
FROM profit_data
GROUP BY month_number, month_name
ORDER BY month_number;
```

### Аналіз результатів:

- Січень: загальний прибуток = 3000, прибуток за попередній місяць = NULL (немає попереднього місяця)
- Лютий: загальний прибуток = 4000, прибуток за попередній місяць = 3000
- Березень: загальний прибуток = 3400, прибуток за попередній місяць = 4000

## Важливі особливості функції LAG

1. **Синтаксис**:
   ```sql
   LAG(column_name [, offset [, default_value]]) OVER ([PARTITION BY partition_expression] ORDER BY sort_expression)
   ```
   
   - `column_name`: стовпець, значення з якого потрібно отримати
   - `offset`: на скільки рядків назад потрібно заглянути (за замовчуванням 1)
   - `default_value`: значення, яке повертається, якщо немає попереднього рядка (за замовчуванням NULL)

2. **NULL для першого рядка**: для першого рядка у вікні (або в усьому наборі даних) функція LAG повертає NULL, якщо не вказано default_value.

3. **Використання з агрегатними функціями**: як показано в другому прикладі, LAG можна використовувати з агрегатними функціями, такими як SUM.

## Висновок

Віконна функція LAG є потужним інструментом для аналізу даних в SQL, особливо коли потрібно порівнювати поточні значення з попередніми. Ця функція часто використовується для:
- Аналізу тенденцій
- Розрахунку змін між періодами
- Порівняння поточних показників з історичними

Функції LAG та LEAD є популярними темами на технічних співбесідах, тому важливо розуміти їх застосування та відмінності між ними.



# Функції ISNULL та COALESCE в SQL

## Вступ до функцій обробки NULL-значень

У цій лекції ми розглянемо дві важливі функції SQL для обробки NULL-значень: ISNULL та COALESCE. Ці функції допомагають замінювати NULL-значення на альтернативні значення, що є дуже корисним при роботі з реальними даними.

## Підготовка даних

Для наших прикладів створимо таблицю `customers`:

```sql
USE prophet_db;

CREATE TABLE customers (
    customer_id INT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    phone_number VARCHAR(20)
);

-- Вставка тестових даних...
```

Переглянемо дані в таблиці:
```sql
SELECT * FROM customers;
```

## Функція ISNULL

Функція ISNULL перевіряє, чи є перший аргумент NULL. Якщо так, вона повертає другий аргумент; якщо ні — повертає перший аргумент.

### Синтаксис:
```sql
ISNULL(expression, replacement_value)
```

### Приклади:

1. Заміна NULL-значення:
```sql
SELECT ISNULL(NULL, 'Перше значення NULL');
```
Результат: `Перше значення NULL`

2. Повернення ненульового значення:
```sql
SELECT ISNULL('ABX', NULL);
```
Результат: `ABX`

3. Обидва значення NULL:
```sql
SELECT ISNULL(NULL, NULL);
```
Результат: `NULL`

## Функція COALESCE

Функція COALESCE перевіряє список аргументів послідовно і повертає перше значення, яке не є NULL.

### Синтаксис:
```sql
COALESCE(expression1, expression2, ..., expressionN)
```

### Приклади:

1. Повернення першого ненульового значення:
```sql
SELECT COALESCE('A', 'B', 'C');
```
Результат: `A`

2. Перше значення NULL, повертається друге:
```sql
SELECT COALESCE(NULL, 'B', 'C');
```
Результат: `B`

3. Перші два значення NULL, повертається третє:
```sql
SELECT COALESCE(NULL, NULL, 'C');
```
Результат: `C`

## Практичне застосування

### Використання ISNULL з таблицею customers:

```sql
SELECT 
    customer_id,
    ISNULL(email, 'Email не доступний') AS email,
    ISNULL(phone_number, 'Номер телефону не доступний') AS phone_number
FROM customers;
```

У цьому запиті:
- Якщо значення email є NULL, замість нього виводиться текст "Email не доступний"
- Якщо значення phone_number є NULL, замість нього виводиться текст "Номер телефону не доступний"

### Використання COALESCE з таблицею customers:

```sql
SELECT 
    customer_id,
    COALESCE(email, phone_number, 'Контакт не доступний') AS [COALESCE Function]
FROM customers;
```

У цьому запиті:
- Спочатку перевіряється email — якщо він не NULL, виводиться його значення
- Якщо email є NULL, перевіряється phone_number — якщо він не NULL, виводиться його значення
- Якщо і email, і phone_number є NULL, виводиться текст "Контакт не доступний"

## Ключові відмінності між ISNULL та COALESCE

1. **Кількість аргументів**:
   - ISNULL приймає рівно два аргументи
   - COALESCE може приймати необмежену кількість аргументів

2. **Логіка роботи**:
   - ISNULL просто замінює NULL на вказане значення
   - COALESCE шукає перше ненульове значення серед усіх аргументів

3. **Гнучкість**:
   - COALESCE є більш гнучкою функцією, оскільки дозволяє перевіряти кілька значень
   - ISNULL має простіший синтаксис для простої заміни NULL-значень

## Висновок

Функції ISNULL та COALESCE є важливими інструментами для роботи з NULL-значеннями в SQL. Вони допомагають забезпечити правильне відображення даних у звітах та уникнути помилок при обробці NULL-значень. Використовуйте ISNULL для простої заміни NULL на альтернативне значення та COALESCE для вибору першого ненульового значення з кількох опцій.


# Функції ISNULL та COALESCE в SQL

## Вступ до функцій обробки NULL-значень

У цій лекції ми розглянемо дві важливі функції SQL для обробки NULL-значень: ISNULL та COALESCE. Ці функції допомагають замінювати NULL-значення на альтернативні значення, що є дуже корисним при роботі з реальними даними.

## Підготовка даних

Для наших прикладів створимо таблицю `customers`:

```sql
USE prophet_db;

CREATE TABLE customers (
    customer_id INT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    phone_number VARCHAR(20)
);

-- Вставка тестових даних...
```

Переглянемо дані в таблиці:
```sql
SELECT * FROM customers;
```

## Функція ISNULL

Функція ISNULL перевіряє, чи є перший аргумент NULL. Якщо так, вона повертає другий аргумент; якщо ні — повертає перший аргумент.

### Синтаксис:
```sql
ISNULL(expression, replacement_value)
```

### Приклади:

1. Заміна NULL-значення:
```sql
SELECT ISNULL(NULL, 'Перше значення NULL');
```
Результат: `Перше значення NULL`

2. Повернення ненульового значення:
```sql
SELECT ISNULL('ABX', NULL);
```
Результат: `ABX`

3. Обидва значення NULL:
```sql
SELECT ISNULL(NULL, NULL);
```
Результат: `NULL`

## Функція COALESCE

Функція COALESCE перевіряє список аргументів послідовно і повертає перше значення, яке не є NULL.

### Синтаксис:
```sql
COALESCE(expression1, expression2, ..., expressionN)
```

### Приклади:

1. Повернення першого ненульового значення:
```sql
SELECT COALESCE('A', 'B', 'C');
```
Результат: `A`

2. Перше значення NULL, повертається друге:
```sql
SELECT COALESCE(NULL, 'B', 'C');
```
Результат: `B`

3. Перші два значення NULL, повертається третє:
```sql
SELECT COALESCE(NULL, NULL, 'C');
```
Результат: `C`

## Практичне застосування

### Використання ISNULL з таблицею customers:

```sql
SELECT 
    customer_id,
    ISNULL(email, 'Email не доступний') AS email,
    ISNULL(phone_number, 'Номер телефону не доступний') AS phone_number
FROM customers;
```

У цьому запиті:
- Якщо значення email є NULL, замість нього виводиться текст "Email не доступний"
- Якщо значення phone_number є NULL, замість нього виводиться текст "Номер телефону не доступний"

### Використання COALESCE з таблицею customers:

```sql
SELECT 
    customer_id,
    COALESCE(email, phone_number, 'Контакт не доступний') AS [COALESCE Function]
FROM customers;
```

У цьому запиті:
- Спочатку перевіряється email — якщо він не NULL, виводиться його значення
- Якщо email є NULL, перевіряється phone_number — якщо він не NULL, виводиться його значення
- Якщо і email, і phone_number є NULL, виводиться текст "Контакт не доступний"

## Ключові відмінності між ISNULL та COALESCE

1. **Кількість аргументів**:
   - ISNULL приймає рівно два аргументи
   - COALESCE може приймати необмежену кількість аргументів

2. **Логіка роботи**:
   - ISNULL просто замінює NULL на вказане значення
   - COALESCE шукає перше ненульове значення серед усіх аргументів

3. **Гнучкість**:
   - COALESCE є більш гнучкою функцією, оскільки дозволяє перевіряти кілька значень
   - ISNULL має простіший синтаксис для простої заміни NULL-значень

## Висновок

Функції ISNULL та COALESCE є важливими інструментами для роботи з NULL-значеннями в SQL. Вони допомагають забезпечити правильне відображення даних у звітах та уникнути помилок при обробці NULL-значень. Використовуйте ISNULL для простої заміни NULL на альтернативне значення та COALESCE для вибору першого ненульового значення з кількох опцій.


# Віконна функція FIRST_VALUE в SQL

## Вступ до функції FIRST_VALUE

Віконна функція FIRST_VALUE дозволяє отримати перше значення у впорядкованому наборі даних в межах вікна. Це особливо корисно, коли потрібно порівняти кожен рядок з першим рядком набору даних або вікна.

## Підготовка середовища для прикладів

Спочатку створимо базу даних та таблицю для наших прикладів:

```sql
CREATE DATABASE window_functions;
USE window_functions;

CREATE TABLE employee_salaries (
    employee_id INT,
    employee_name VARCHAR(50),
    salary DECIMAL(10,2),
    department VARCHAR(50)
);

-- Вставка тестових даних...
```

Переглянемо дані в таблиці:
```sql
SELECT * FROM employee_salaries;
```

Наша таблиця містить інформацію про працівників з колонками: ID працівника, ім'я, зарплата та відділ.

## Базове використання FIRST_VALUE

### Приклад 1: Знаходження мінімальної зарплати

```sql
SELECT *,
    FIRST_VALUE(salary) OVER (ORDER BY salary) AS [Minimum Salary]
FROM employee_salaries;
```

У цьому запиті:
- `FIRST_VALUE(salary)` вибирає значення зарплати з першого рядка у відсортованому наборі
- `ORDER BY salary` сортує дані за зростанням зарплати
- Результатом є додатковий стовпець, який показує мінімальну зарплату для кожного рядка

### Приклад 2: Знаходження імені працівника з мінімальною зарплатою

```sql
SELECT *,
    FIRST_VALUE(employee_name) OVER (ORDER BY salary) AS [Employee with Minimum Salary]
FROM employee_salaries;
```

Тепер замість значення мінімальної зарплати ми отримуємо ім'я працівника, який отримує найменшу зарплату.

### Приклад 3: Комбінування кількох FIRST_VALUE

Можна додати декілька стовпців з використанням функції FIRST_VALUE:

```sql
SELECT *,
    FIRST_VALUE(employee_name) OVER (ORDER BY salary) AS [Employee with Minimum Salary],
    FIRST_VALUE(salary) OVER (ORDER BY salary) AS [Minimum Salary]
FROM employee_salaries;
```

Цей запит виводить і ім'я працівника з мінімальною зарплатою, і значення мінімальної зарплати.

## Використання FIRST_VALUE з PARTITION BY

Функція FIRST_VALUE стає ще потужнішою, коли використовується з конструкцією PARTITION BY, яка дозволяє створювати окремі "вікна" даних.

### Приклад 4: Знаходження працівника з мінімальною зарплатою у кожному відділі

```sql
SELECT *,
    FIRST_VALUE(employee_id) OVER (
        PARTITION BY department 
        ORDER BY salary
    ) AS [First Value]
FROM employee_salaries;
```

У цьому запиті:
- `PARTITION BY department` створює окремі вікна для кожного відділу
- `ORDER BY salary` сортує дані за зростанням зарплати в межах кожного відділу
- Результат показує ID працівника з найнижчою зарплатою в кожному відділі

### Приклад 5: Знаходження працівника з максимальною зарплатою у кожному відділі

Змінивши порядок сортування на спадання, ми можемо знайти працівника з найвищою зарплатою:

```sql
SELECT *,
    FIRST_VALUE(employee_id) OVER (
        PARTITION BY department 
        ORDER BY salary DESC
    ) AS [First Value EID],
    FIRST_VALUE(employee_name) OVER (
        PARTITION BY department 
        ORDER BY salary DESC
    ) AS [First Value EName]
FROM employee_salaries;
```

Тепер у результатах ми бачимо:
- У відділі фінансів: ID працівника з найвищою зарплатою - 5 (Єва)
- У відділі HR: ID працівника з найвищою зарплатою - 2
- У відділі IT: ID працівника з найвищою зарплатою - 8

## Висновок

Віконна функція FIRST_VALUE є потужним інструментом для аналізу даних, особливо коли потрібно знайти перше значення в упорядкованому наборі даних. У поєднанні з PARTITION BY, вона дозволяє знаходити "перші" значення в межах груп, що робить її корисною для аналізу мінімальних, максимальних або інших "крайніх" значень у різних категоріях даних.

У наступній лекції ми розглянемо функцію LAST_VALUE, яка працює аналогічно, але знаходить останнє значення в упорядкованому наборі даних.


# Віконна функція LAST_VALUE в SQL

## Вступ до функції LAST_VALUE

Віконна функція LAST_VALUE, як і розглянута в попередній лекції функція FIRST_VALUE, дозволяє отримати значення з конкретного рядка у впорядкованому наборі даних у межах вікна. Функція LAST_VALUE повертає значення з останнього рядка в упорядкованому вікні.

## Використання таблиці employee_salaries

Продовжимо використовувати таблицю `employee_salaries` з попередньої лекції. Нагадаємо структуру таблиці:
```sql
SELECT * FROM employee_salaries;
```

Таблиця містить інформацію про працівників: ID, ім'я, зарплату та відділ.

## Важливість конструкції ROWS BETWEEN

### Некоректне використання LAST_VALUE

Спробуємо знайти працівника з найнижчою зарплатою:

```sql
SELECT *,
    LAST_VALUE(employee_name) OVER (ORDER BY salary DESC) AS [Employee with lowest salary]
FROM employee_salaries;
```

Але результат виявляється неправильним! Для кожного рядка значення функції LAST_VALUE збігається з поточним рядком.

### Чому це відбувається?

За замовчуванням вікно для функції LAST_VALUE включає рядки від початку розділу до поточного рядка. Тому:
- Для першого рядка вікно містить лише один рядок
- Для другого рядка вікно містить два рядки
- І так далі

Це призводить до того, що "останнім" рядком у вікні завжди є поточний рядок.

### Коректне використання LAST_VALUE

Щоб виправити цю проблему, потрібно явно вказати межі вікна:

```sql
SELECT *,
    LAST_VALUE(employee_name) OVER (
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS [Employee with lowest salary]
FROM employee_salaries;
```

Конструкція `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` вказує, що вікно має включати всі рядки від початку до кінця набору даних.

## Отримання значення зарплати

Можна також отримати значення найнижчої зарплати:

```sql
SELECT *,
    LAST_VALUE(employee_name) OVER (
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS [Employee with lowest salary],
    LAST_VALUE(salary) OVER (
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS [Lowest salary]
FROM employee_salaries;
```

## Використання LAST_VALUE з PARTITION BY

Функцію LAST_VALUE можна використовувати з конструкцією PARTITION BY для аналізу окремих груп даних:

```sql
SELECT *,
    LAST_VALUE(employee_name) OVER (
        PARTITION BY department
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS [Employee with lowest salary],
    LAST_VALUE(salary) OVER (
        PARTITION BY department
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS [Lowest salary]
FROM employee_salaries;
```

У цьому випадку ми отримуємо працівника з найнижчою зарплатою та значення найнижчої зарплати для кожного відділу окремо.

## Отримання працівників з найвищою зарплатою

Змінивши порядок сортування з спадного (DESC) на зростаючий (ASC), можна отримати працівників з найвищою зарплатою:

```sql
SELECT *,
    LAST_VALUE(employee_name) OVER (
        PARTITION BY department
        ORDER BY salary ASC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS [Employee with highest salary],
    LAST_VALUE(salary) OVER (
        PARTITION BY department
        ORDER BY salary ASC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS [Highest salary]
FROM employee_salaries;
```

## Альтернатива: використання FIRST_VALUE

Замість LAST_VALUE з ASC можна використати FIRST_VALUE з DESC для отримання того ж результату:

```sql
SELECT *,
    FIRST_VALUE(employee_name) OVER (
        PARTITION BY department
        ORDER BY salary DESC
    ) AS [Employee with highest salary],
    FIRST_VALUE(salary) OVER (
        PARTITION BY department
        ORDER BY salary DESC
    ) AS [Highest salary]
FROM employee_salaries;
```

Обидва запити дають однаковий результат, але FIRST_VALUE не потребує явного зазначення меж вікна для коректної роботи.

## Висновок

Віконна функція LAST_VALUE є потужним інструментом для аналізу даних, але потребує уваги при використанні:

1. Завжди вказуйте межі вікна за допомогою `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`, щоб включити всі рядки
2. Враховуйте порядок сортування: DESC для пошуку мінімальних значень, ASC для максимальних
3. Використовуйте PARTITION BY для аналізу окремих груп даних
4. Як альтернативу, можна використовувати FIRST_VALUE з протилежним порядком сортування

Розуміння різниці між FIRST_VALUE та LAST_VALUE та правильне використання конструкції ROWS BETWEEN є ключовими для успішного застосування цих функцій у складних аналітичних запитах.


# Advanced SQL

# Загальні табличні вирази (Common Table Expressions, CTE) в SQL

## Вступ до CTE

Загальний табличний вираз (Common Table Expression, CTE) – це тимчасовий набір результатів, який можна використовувати разом із командами SELECT, INSERT, UPDATE або DELETE. Основні характеристики CTE:
- Це тимчасовий набір результатів
- Створюється за допомогою ключового слова WITH
- Допомагає спрощувати запити та робити код більш зрозумілим
- Розбиває складні запити на простіші частини

## Підготовка середовища для прикладів

Працюватимемо з таблицею `employees` з бази даних `employee_details`. Щоб не змінювати оригінальну таблицю, створимо тимчасову таблицю:

```sql
SELECT * INTO #temp1 FROM employees;
```

## Приклад 1: Основи використання CTE з SELECT

```sql
WITH CTE AS (
    SELECT * FROM #temp1
)
SELECT * FROM CTE;
```

У цьому прикладі:
- Ключове слово WITH вказує на початок визначення CTE
- CTE – це назва нашого табличного виразу
- У дужках після AS ми визначаємо запит для CTE
- Після визначення CTE ми використовуємо його в запиті SELECT

**Важливо:** Запит, який використовує CTE, повинен йти одразу після його визначення.

## Приклад 2: Вибіркові дані у CTE

```sql
WITH test_CTE AS (
    SELECT employee_id, first_name 
    FROM #temp1
    WHERE employee_id IN (2, 4)
)
SELECT * FROM test_CTE;
```

У цьому прикладі CTE містить лише два стовпці (employee_id і first_name) та фільтрує дані для працівників з ID 2 та 4.

## Приклад 3: Використання CTE з INSERT

```sql
WITH common_table_expression AS (
    SELECT * FROM #temp1
    WHERE employee_id IN (1, 2, 3)
)
SELECT * INTO #temp2 FROM common_table_expression;
```

Цей приклад створює нову тимчасову таблицю #temp2 та вставляє в неї дані з CTE.

## Приклад 4: Використання CTE з UPDATE

```sql
WITH CTE_one AS (
    SELECT * FROM #temp1
    WHERE employee_id IN (2, 4, 6)
)
UPDATE #temp1
SET employee_id = 101
WHERE employee_id IN (SELECT DISTINCT employee_id FROM CTE_one);
```

У цьому прикладі ми використовуємо CTE для оновлення значень employee_id в основній таблиці. Після виконання цього запиту employee_id 2, 4 та 6 будуть змінені на 101.

## Приклад 5: Використання CTE з DELETE

```sql
WITH CTE_two AS (
    SELECT * FROM #temp1
    WHERE employee_id = 1
)
DELETE FROM #temp1
WHERE employee_id IN (SELECT DISTINCT employee_id FROM CTE_two);
```

Цей приклад використовує CTE для видалення запису з employee_id = 1 з таблиці #temp1.

## Приклад 6: Повторне вставлення даних через CTE

```sql
WITH CTE_three AS (
    SELECT * FROM #temp1
    WHERE employee_id = 101
)
INSERT INTO #temp1
SELECT * FROM CTE_three;
```

Цей приклад вставляє дані в таблицю #temp1, використовуючи як джерело записи з тієї ж таблиці, що мають employee_id = 101. Це фактично дублює ці записи.

## Важливі аспекти використання CTE

1. **Синтаксис:** Завжди починається з ключового слова WITH, за яким іде назва CTE, потім AS і запит у дужках
2. **Область видимості:** CTE доступний тільки для запиту, який йде безпосередньо після його визначення
3. **Виконання:** Визначення CTE та запит, що його використовує, повинні виконуватися разом
4. **Гнучкість:** Можна використовувати з командами SELECT, INSERT, UPDATE та DELETE
5. **Читабельність:** Спрощує складні запити, розбиваючи їх на логічні частини

## Висновок

Загальні табличні вирази (CTE) – це потужний інструмент SQL, який дозволяє спростити складні запити, покращити їх читабельність і структуру. У наступних лекціях ми розглянемо використання кількох CTE в одному запиті та рекурсивні CTE для вирішення більш складних завдань.



# Множинні загальні табличні вирази (Multiple CTEs) в SQL

## Вступ до множинних CTE

У попередній лекції ми розглянули основи використання загальних табличних виразів (CTE). Сьогодні ми розглянемо, як визначати та використовувати кілька CTE в одному запиті за допомогою лише одного ключового слова WITH.

## Підготовка середовища для прикладів

Спочатку створимо копію таблиці `employees` для наших експериментів:

```sql
SELECT * INTO #1 FROM dbo.employees;
```

## Приклад 1: Визначення кількох CTE з одним WITH

```sql
WITH CTE1 AS (
    SELECT * FROM #1 
    WHERE employee_id IN (1, 2)
),
CTE2 AS (
    SELECT * FROM #1 
    WHERE employee_id IN (3, 4)
)
SELECT * FROM CTE1
UNION ALL
SELECT * FROM CTE2;
```

У цьому прикладі:
- Ми визначаємо два CTE: CTE1 та CTE2
- Ключове слово WITH використовується лише один раз на початку
- Після визначення першого CTE ставиться кома, і йде визначення другого CTE
- В основному запиті ми об'єднуємо результати обох CTE за допомогою UNION ALL

Результат містить записи, де employee_id = 1, 2, 3 або 4.

## Приклад 2: Вставка даних з кількох CTE у нову таблицю

```sql
WITH CTE3 AS (
    SELECT employee_id, first_name 
    FROM #1 
    WHERE employee_id = 1
),
CTE4 AS (
    SELECT employee_id, first_name 
    FROM #1 
    WHERE employee_id = 3
)
SELECT * INTO #2 FROM (
    SELECT * FROM CTE3
    UNION ALL
    SELECT * FROM CTE4
) X;
```

У цьому прикладі:
- Ми визначаємо два CTE, кожний з яких вибирає тільки employee_id та first_name
- CTE3 вибирає дані для employee_id = 1
- CTE4 вибирає дані для employee_id = 3
- Ми об'єднуємо результати обох CTE і створюємо нову таблицю #2
- Підзапит повинен мати аліас (X у нашому випадку)

Результати: у таблиці #2 будуть два записи з employee_id = 1 та employee_id = 3.

## Приклад 3: Вставка даних з кількох CTE в існуючу таблицю

```sql
WITH CTE3 AS (
    SELECT employee_id, first_name 
    FROM #1 
    WHERE employee_id = 1
),
CTE4 AS (
    SELECT employee_id, first_name 
    FROM #1 
    WHERE employee_id = 3
)
INSERT INTO #2
SELECT * FROM CTE3
UNION ALL
SELECT * FROM CTE4;
```

У цьому прикладі:
- Використовуємо ті самі CTE, що й у Прикладі 2
- Замість створення нової таблиці, додаємо дані до існуючої таблиці #2
- Після виконання таблиця #2 міститиме 4 записи: по два для employee_id = 1 та employee_id = 3

## Приклад 4: Видалення даних з використанням кількох CTE

```sql
WITH CTE3 AS (
    SELECT employee_id, first_name, salary 
    FROM #1 
    WHERE employee_id = 2
),
CTE4 AS (
    SELECT employee_id, first_name, salary 
    FROM #1 
    WHERE employee_id = 4
)
DELETE FROM #1
WHERE employee_id IN (
    SELECT DISTINCT employee_id FROM CTE3
    UNION ALL
    SELECT DISTINCT employee_id FROM CTE4
);
```

У цьому прикладі:
- Визначаємо два CTE для вибору даних з employee_id = 2 та employee_id = 4
- Використовуємо ці CTE для формування списку employee_id, які потрібно видалити
- Видаляємо записи з таблиці #1, де employee_id знаходиться в цьому списку

Після виконання з таблиці #1 будуть видалені всі записи, де employee_id = 2 або employee_id = 4.

## Приклад 5: Оновлення даних з використанням кількох CTE

```sql
WITH CTE3 AS (
    SELECT employee_id, first_name, salary 
    FROM #1 
    WHERE employee_id = 9
),
CTE4 AS (
    SELECT employee_id, first_name, salary 
    FROM #1 
    WHERE employee_id = 10
)
UPDATE #1
SET employee_id = 100
WHERE employee_id NOT IN (
    SELECT DISTINCT employee_id FROM CTE3
    UNION ALL
    SELECT DISTINCT employee_id FROM CTE4
);
```

У цьому прикладі:
- Визначаємо два CTE для вибору даних з employee_id = 9 та employee_id = 10
- Використовуємо ці CTE для формування списку employee_id, які НЕ потрібно оновлювати
- Оновлюємо всі інші записи, встановлюючи employee_id = 100

Після виконання в таблиці #1 залишаться тільки записи з employee_id = 9, employee_id = 10, а всі інші матимуть employee_id = 100.

## Висновок

Використання кількох CTE в одному запиті за допомогою одного ключового слова WITH значно спрощує складні запити та підвищує їх читабельність. Це особливо корисно, коли вам потрібно зробити кілька пов'язаних операцій з даними або працювати з підмножинами даних, визначеними різними умовами.

Кілька важливих моментів:
- Всі CTE, крім першого, починаються з коми після закриття дужок попереднього CTE
- Ключове слово WITH використовується тільки один раз
- CTE можуть посилатися на таблиці і навіть на інші CTE, визначені раніше
- CTE можна використовувати з командами SELECT, INSERT, UPDATE та DELETE

У наступній лекції ми розглянемо рекурсивні CTE, які дозволяють працювати з ієрархічними даними та розв'язувати ще складніші завдання.



# Рекурсивні загальні табличні вирази (Recursive CTE) в SQL

## Вступ до рекурсивних CTE

Рекурсивний загальний табличний вираз (Recursive CTE) — це спеціальний вид CTE, який посилається сам на себе. Ця можливість дозволяє вирішувати задачі, що потребують ітеративної обробки або роботи з ієрархічними структурами даних.

## Структура рекурсивного CTE

Рекурсивний CTE складається з двох основних частин:
1. **Якірний запит** (Anchor query) — початкове значення, з якого починається рекурсія
2. **Рекурсивний запит** (Recursive query) — запит, що посилається на сам CTE

Ці дві частини з'єднуються оператором `UNION ALL`.

## Приклад обчислення послідовності чисел

Розглянемо простий приклад створення послідовності чисел від 1 до 5:

```sql
WITH rCTE AS (
    -- Якірний запит
    SELECT 1 AS n
    
    UNION ALL
    
    -- Рекурсивний запит
    SELECT n + 1
    FROM rCTE
    WHERE n <= 4
)
SELECT * FROM rCTE;
```

### Пояснення виконання:

1. **Крок 1**: Виконується якірний запит:
   - Результат: n = 1
   
2. **Крок 2**: Результат якірного запиту стає вхідними даними для рекурсивного запиту:
   - Перевіряється умова: 1 <= 4? (Так)
   - Обчислюється: n + 1 = 1 + 1 = 2
   - Результат: n = 2
   
3. **Крок 3**: Результат попереднього кроку стає вхідними даними для наступної ітерації:
   - Перевіряється умова: 2 <= 4? (Так)
   - Обчислюється: n + 1 = 2 + 1 = 3
   - Результат: n = 3
   
4. **Крок 4**: Результат попереднього кроку стає вхідними даними для наступної ітерації:
   - Перевіряється умова: 3 <= 4? (Так)
   - Обчислюється: n + 1 = 3 + 1 = 4
   - Результат: n = 4
   
5. **Крок 5**: Результат попереднього кроку стає вхідними даними для наступної ітерації:
   - Перевіряється умова: 4 <= 4? (Так)
   - Обчислюється: n + 1 = 4 + 1 = 5
   - Результат: n = 5
   
6. **Крок 6**: Результат попереднього кроку стає вхідними даними для наступної ітерації:
   - Перевіряється умова: 5 <= 4? (Ні)
   - Рекурсія зупиняється, оскільки умова не виконується
   
7. **Кінцевий результат**: Об'єднання всіх проміжних результатів:
   - n = 1, 2, 3, 4, 5

## Обчислення факторіалу за допомогою рекурсивного CTE

Факторіал числа n (позначається n!) — це добуток усіх цілих чисел від 1 до n:

- 3! = 3 × 2 × 1 = 6
- 5! = 5 × 4 × 3 × 2 × 1 = 120

Щоб обчислити факторіал за допомогою рекурсивного CTE, спочатку згенеруємо послідовність чисел, а потім обчислимо їх добуток:

```sql
WITH rCTE AS (
    -- Якірний запит
    SELECT 1 AS n
    
    UNION ALL
    
    -- Рекурсивний запит
    SELECT n + 1
    FROM rCTE
    WHERE n <= 4  -- Для факторіалу 5 (до числа 5 включно)
)
SELECT EXP(SUM(LOG(n))) AS Factorial
FROM rCTE;
```

### Математичне пояснення обчислення добутку:

Для обчислення добутку використовується математична властивість логарифмів:
- log(m) + log(n) = log(m × n)

Щоб знайти добуток чисел:
1. Обчислюємо логарифм кожного числа
2. Додаємо ці логарифми
3. Застосовуємо експоненту до суми

Формула: EXP(SUM(LOG(n))) = EXP(log(1) + log(2) + log(3) + ... + log(5)) = 1 × 2 × 3 × ... × 5

### Важливі зауваження:

- Для обчислення факторіалу числа n, у умові WHERE потрібно вказати n-1
- Результатом буде n! (факторіал числа n)
- Наприклад, для обчислення 3! у умові WHERE вказуємо 2 (n <= 2)

## Висновок

Рекурсивні загальні табличні вирази (Recursive CTE) є потужним інструментом SQL для вирішення задач, що потребують ітеративної обробки. Крім розглянутого прикладу з факторіалом, рекурсивні CTE часто використовуються для:

- Роботи з ієрархічними даними (наприклад, організаційна структура компанії)
- Обходу деревоподібних структур
- Генерації послідовностей
- Обчислення складних математичних функцій

Розуміння принципів роботи рекурсивних CTE дозволяє вирішувати багато складних завдань безпосередньо на рівні бази даних без використання процедурних мов програмування.




# Збережені процедури (Stored Procedures) в SQL

## Вступ до збережених процедур

Збережена процедура – це група інструкцій Transact-SQL, об'єднаних в одну логічну одиницю. Збережені процедури особливо корисні, коли певний фрагмент коду потрібно використовувати повторно. Вони покращують повторне використання коду та спрощують підтримку складних запитів.

## Підготовка середовища для прикладів

Для наших прикладів створимо нову базу даних та таблицю:

```sql
CREATE DATABASE test_db;
USE test_db;

CREATE TABLE employees (
    employee_id INT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    -- інші стовпці
);

-- Вставка тестових даних
INSERT INTO employees VALUES
(1, 'Ім'я1', 'Прізвище1'),
-- інші рядки
```

## Створення збереженої процедури

### Синтаксис створення процедури:

```sql
CREATE PROCEDURE назва_процедури
AS
BEGIN
    -- Тіло процедури (SQL-запити)
END
```

### Приклад 1: Проста процедура для вибору всіх даних

```sql
CREATE PROCEDURE SP_test
AS
BEGIN
    SELECT * FROM employees;
END
```

У цьому прикладі:
- `CREATE PROCEDURE` (або скорочено `CREATE PROC`) вказує на створення процедури
- `SP_test` – це назва процедури (префікс SP_ допомагає ідентифікувати її як процедуру)
- `AS BEGIN ... END` – блок, що містить тіло процедури

## Виклик збереженої процедури

Є кілька способів викликати збережену процедуру:

1. Просто вказати назву процедури:
```sql
SP_test
```

2. Використати команду EXECUTE (або скорочено EXEC):
```sql
EXECUTE SP_test
```

3. Або:
```sql
EXEC SP_test
```

Усі три способи дадуть однаковий результат – виконають SQL-запит, що міститься всередині процедури.

## Створення більш складної процедури

### Приклад 2: Процедура для вибору конкретних стовпців

```sql
CREATE PROC SP_test_one
AS
BEGIN
    SELECT first_name, last_name FROM employees;
END
```

У цьому прикладі процедура повертає лише імена та прізвища працівників, а не всі стовпці.

## Зміна існуючої процедури

Якщо потрібно внести зміни до вже створеної процедури, використовується команда `ALTER PROCEDURE`:

```sql
ALTER PROCEDURE SP_test_one
AS
BEGIN
    SELECT employee_id, first_name, last_name FROM employees;
END
```

У цьому прикладі ми змінили процедуру `SP_test_one`, додавши до її результатів стовпець `employee_id`.

## Важливі аспекти збережених процедур

1. **Повторне використання коду**:
   - У реальних проектах процедури можуть містити сотні або тисячі рядків коду
   - Замість повторного написання складного коду, можна просто викликати процедуру

2. **Альтернативні синтаксиси**:
   - `CREATE PROCEDURE` або коротко `CREATE PROC`
   - `ALTER PROCEDURE` або коротко `ALTER PROC`
   - `EXECUTE` або коротко `EXEC`

3. **Організація коду**:
   - Процедури допомагають структурувати код
   - Спрощують підтримку та модифікацію

## Висновок

Збережені процедури – це потужний інструмент для організації SQL-коду, особливо в складних проектах. Вони дозволяють інкапсулювати логіку, спрощують повторне використання коду та роблять його більш модульним та зрозумілим.



# Представлення (Views) в SQL

## Вступ до представлень

Представлення (View) – це віртуальна таблиця, яка не займає фізичного простору в базі даних. Представлення створюється на основі SQL-запиту до існуючих таблиць. По суті, представлення – це збережений SQL-запит, результати якого можна використовувати як звичайну таблицю.

## Підготовка середовища для прикладів

Для наших прикладів використаємо таблицю `employees` з бази даних `test_db`. Створимо також резервну копію таблиці для демонстрації оновлення представлень:

```sql
SELECT * INTO emp_backup FROM employees;
```

## Створення представлення

### Синтаксис створення представлення:

```sql
CREATE VIEW назва_представлення AS
(
    SQL-запит
);
```

### Приклад 1: Просте представлення

```sql
CREATE VIEW view_one AS
(
    SELECT * FROM emp_backup
);
```

Після створення представлення можна звертатися до нього так само, як до таблиці:

```sql
SELECT * FROM view_one;
```

## Переваги використання представлень

### 1. Впровадження безпеки

Представлення дозволяють обмежувати доступ до певних стовпців або рядків таблиці:

#### Безпека на рівні стовпців:

```sql
CREATE VIEW view_two AS
(
    SELECT 
        employee_id, 
        first_name, 
        last_name, 
        email, 
        department_id, 
        hire_date
    FROM emp_backup
);
```

У цьому прикладі представлення `view_two` не містить стовпця `salary`, тому користувачі, які мають доступ лише до цього представлення, не зможуть бачити зарплати працівників.

#### Безпека на рівні рядків:

Можна також обмежити доступ до певних рядків, наприклад, дозволити бачити лише працівників з певних відділів або з певними ідентифікаторами.

### 2. Зменшення складності коду

Представлення дозволяють інкапсулювати складні запити:
- Можна створити представлення для складних запитів із з'єднаннями (JOIN)
- Користувачі можуть використовувати просту команду SELECT для доступу до результатів складного запиту
- Особливо корисно для користувачів з нетехнічним фоном, які не володіють складним SQL

## Оновлення даних через представлення

Представлення в SQL Server можна оновлювати, що впливатиме на базові таблиці:

```sql
UPDATE view_one 
SET employee_id = 100;
```

Після виконання цього оновлення:
- У представленні `view_one` усі значення `employee_id` стануть рівними 100
- Ці зміни також відобразяться в базовій таблиці `emp_backup`

**Важливо:** Оновлення представлення змінює дані в базовій таблиці, оскільки представлення є лише "вікном" до цих даних. Це потрібно враховувати при роботі з представленнями.

## Видалення представлення

Представлення можна видалити за допомогою команди DROP:

```sql
DROP VIEW view_two;
```

Після видалення представлення спроба отримати до нього доступ призведе до помилки.

## Висновок

Представлення в SQL – це потужний інструмент, який допомагає:
- Забезпечувати безпеку даних на рівні стовпців та рядків
- Зменшувати складність запитів для кінцевих користувачів
- Надавати спрощений доступ до даних без змін базової структури таблиць

При роботі з представленнями важливо пам'ятати, що вони відображають дані з базових таблиць, і будь-які зміни через представлення впливають на ці таблиці.


# Індекси в Microsoft SQL Server

## Вступ до індексів

Розгляньмо спочатку приклад з реального життя. Уявіть, що вам дали книгу на 500 сторінок і попросили знайти певний розділ, але ця книга не має змісту (індексу). Що ви робитимете? Доведеться перегортати сторінку за сторінкою, поки не знайдете потрібний розділ. Це забере багато часу і зменшить вашу ефективність.

А тепер уявіть, що книга має зміст. Ви швидко знаходите в ньому потрібний розділ і відразу переходите на потрібну сторінку, заощаджуючи час і зусилля.

Схожий принцип діє в Microsoft SQL Server. Коли сервер отримує інструкцію вибрати дані з таблиці, йому доводиться сканувати всю таблицю, якщо немає індексів. Це зменшує продуктивність і споживає більше часу.

## Що таке індекси?

Індекси в SQL Server – це спеціальні структури даних, які покращують швидкість пошуку даних у таблицях або представленнях. Індекси визначаються для одного або кількох стовпців таблиці та зберігають дані в відсортованому вигляді, що дозволяє SQL Server швидше знаходити потрібні записи без сканування всієї таблиці.

## Створення індексу

### Синтаксис створення індексу:

```sql
CREATE INDEX назва_індексу
ON назва_таблиці (стовпець [ASC|DESC], ...)
```

### Приклад 1: Створення індексу для одного стовпця

```sql
CREATE INDEX ix_one
ON dbo.employees (salary DESC);
```

У цьому прикладі:
- `ix_one` – назва індексу
- `dbo.employees` – таблиця, для якої створюється індекс
- `salary DESC` – стовпець, за яким створюється індекс, відсортований за спаданням

### Приклад 2: Створення індексу для кількох стовпців

```sql
CREATE INDEX ix_two
ON dbo.employees (first_name, last_name);
```

У цьому прикладі створюється індекс для комбінації стовпців `first_name` та `last_name`.

## Перевірка створених індексів

Після створення індексу можна переглянути його в структурі бази даних:
1. Виберіть базу даних в Object Explorer
2. Розгорніть вузол "Таблиці"
3. Знайдіть потрібну таблицю і розгорніть її
4. Розгорніть вузол "Індекси"
5. Тут ви побачите всі створені індекси для таблиці

## Видалення індексу

Індекси можна видалити за допомогою команди DROP INDEX:

```sql
DROP INDEX dbo.employees.ix_one;
```

Після виконання цієї команди індекс буде видалено з таблиці.

## Типи індексів

У SQL Server є два основних типи індексів:
1. **Кластеризовані індекси** – визначають фізичний порядок даних у таблиці
2. **Некластеризовані індекси** – створюють окрему структуру, що посилається на рядки таблиці

За замовчуванням створюються некластеризовані індекси, як ми бачили в прикладах вище. Детальніше про ці типи індексів ми поговоримо в наступних лекціях.

## Висновок

Індекси – це потужний інструмент для оптимізації продуктивності запитів у SQL Server. Вони допомагають швидше знаходити потрібні дані, особливо у великих таблицях. Проте важливо пам'ятати, що індекси займають додатковий простір і можуть уповільнювати операції вставки, оновлення та видалення, оскільки індекси також потрібно оновлювати. Тому важливо створювати індекси лише для тих стовпців, які часто використовуються у пошукових запитах.

У наступних лекціях ми детальніше розглянемо кластеризовані та некластеризовані індекси та особливості їх використання.


# Кластеризовані індекси в SQL Server

## Вступ до кластеризованих індексів

Кластеризований індекс – це особливий тип індексу в SQL Server, який визначає фізичний порядок зберігання даних у таблиці. На відміну від некластеризованих індексів, кластеризований індекс безпосередньо впливає на те, як записи розташовані в таблиці.

## Підготовка середовища для прикладів

Спочатку створимо базу даних та таблицю для наших прикладів:

```sql
CREATE DATABASE test_index;
USE test_index;

-- Видалення таблиці, якщо вона існує
DROP TABLE IF EXISTS students;

-- Створення таблиці students
CREATE TABLE students (
    id INT,
    name VARCHAR(50),
    age INT,
    gender VARCHAR(10)
);

-- Вставка тестових даних
INSERT INTO students VALUES
(1, 'Іван', 20, 'Male'),
(2, 'Марія', 22, 'Female'),
-- інші дані
```

## Створення кластеризованого індексу

### Синтаксис створення:

```sql
CREATE CLUSTERED INDEX назва_індексу
ON назва_таблиці (стовпець [ASC|DESC], ...);
```

### Приклад 1: Простий кластеризований індекс

```sql
CREATE CLUSTERED INDEX ix_one
ON students (id);
```

Після виконання цієї команди, якщо ми виконаємо `SELECT * FROM students`, ми побачимо, що дані відсортовані за зростанням `id`. Це відбувається тому, що кластеризований індекс визначає фізичний порядок даних у таблиці.

### Приклад 2: Кластеризований індекс зі спаданням

Спершу потрібно видалити існуючий кластеризований індекс, оскільки в таблиці може бути лише один кластеризований індекс:

```sql
DROP INDEX ix_one ON students;

CREATE CLUSTERED INDEX ix_two
ON students (id DESC);
```

Тепер, якщо ми виконаємо `SELECT * FROM students`, дані будуть відсортовані за спаданням стовпця `id`.

## Важливі особливості кластеризованих індексів

1. **Обмеження на одну таблицю:**
   - У таблиці може бути лише один кластеризований індекс
   - Це зумовлено тим, що фізичний порядок даних може бути лише один

2. **Вплив на фізичне зберігання:**
   - Кластеризований індекс визначає фізичний порядок даних у таблиці
   - Це впливає на результат запитів, навіть без явного сортування

## Композитний кластеризований індекс

Кластеризований індекс може бути створений на основі кількох стовпців. Такий індекс називається композитним.

### Приклад композитного індексу:

```sql
DROP INDEX ix_two ON students;

CREATE CLUSTERED INDEX ix_three
ON students (gender DESC, age ASC);
```

Після створення такого індексу дані будуть відсортовані спочатку за спаданням стовпця `gender`, а потім за зростанням стовпця `age` всередині кожної групи `gender`.

Результат запиту `SELECT * FROM students` покаже дані спершу для 'Male', потім для 'Female', а в межах кожної статі – відсортовані за зростанням віку.

## Перегляд індексів у Object Explorer

Створені індекси можна переглянути в Object Explorer:
1. Розгорніть базу даних (test_index)
2. Розгорніть "Таблиці"
3. Знайдіть таблицю "students"
4. Розгорніть "Індекси"
5. Ви побачите всі індекси, створені для таблиці

## Висновок

Кластеризовані індекси – це потужний інструмент для оптимізації продуктивності запитів у SQL Server:
- Вони визначають фізичний порядок даних у таблиці
- На одну таблицю може бути створений лише один кластеризований індекс
- Індекс може базуватися на одному або кількох стовпцях
- Вони особливо корисні для стовпців, які часто використовуються для пошуку, сортування або об'єднання

У наступній лекції ми розглянемо некластеризовані індекси та їх відмінності від кластеризованих.


# Некластеризовані індекси в SQL Server

## Вступ до некластеризованих індексів

У попередній лекції ми розглянули кластеризовані індекси, а сьогодні обговоримо некластеризовані індекси та їх відмінності від кластеризованих.

## Створення некластеризованого індексу

### Синтаксис створення:

```sql
CREATE NONCLUSTERED INDEX назва_індексу
ON назва_таблиці (стовпець [ASC|DESC], ...);
```

### Приклад 1: Простий некластеризований індекс

```sql
CREATE NONCLUSTERED INDEX ix2
ON students (id);
```

Після виконання цієї команди буде створено некластеризований індекс для стовпця `id`.

### Приклад 2: Композитний некластеризований індекс

```sql
CREATE NONCLUSTERED INDEX ix3
ON students (gender, age);
```

У цьому прикладі створюється некластеризований індекс на основі двох стовпців: `gender` та `age`.

## Ключові відмінності від кластеризованих індексів

1. **Кількість індексів на таблицю:**
   - У таблиці може бути кілька некластеризованих індексів
   - У таблиці може бути лише один кластеризований індекс

2. **Вплив на фізичне зберігання:**
   - Некластеризовані індекси не впливають на фізичний порядок даних у таблиці
   - Кластеризований індекс визначає фізичний порядок даних

3. **Структура зберігання:**
   - Некластеризовані індекси зберігаються окремо від даних таблиці
   - Вони вимагають додаткового дискового простору
   - Містять посилання на фактичні рядки даних

4. **Швидкість доступу:**
   - Кластеризовані індекси зазвичай швидші, особливо при виборі багатьох стовпців
   - Некластеризовані індекси можуть вимагати додаткового пошуку, якщо вибрані стовпці не входять до індексу

## Практичний приклад різниці в роботі

Розглянемо запит:
```sql
SELECT name, age, gender FROM students WHERE id = 2;
```

### Для кластеризованого індексу на `id`:
- SQL Server знаходить рядок з `id = 2` безпосередньо в таблиці
- Одразу отримує всі потрібні стовпці з цього рядка

### Для некластеризованого індексу на `id`:
- SQL Server знаходить значення `id = 2` в індексі
- Індекс містить посилання на фактичний рядок у таблиці
- Необхідно виконати додатковий пошук для отримання значень `name`, `age` та `gender`, оскільки вони не входять до індексу
- Цей додатковий пошук уповільнює виконання запиту

## Видалення некластеризованого індексу

Некластеризований індекс можна видалити так само, як і кластеризований:

```sql
DROP INDEX ix2 ON students;
```

## Узагальнення відмінностей між кластеризованими та некластеризованими індексами

| Характеристика | Кластеризований індекс | Некластеризований індекс |
|----------------|------------------------|---------------------------|
| Кількість на таблицю | Лише один | Може бути кілька |
| Фізичний порядок даних | Визначає порядок | Не впливає |
| Зберігання | На тій самій таблиці | Окремо від таблиці |
| Додатковий простір | Мінімальний | Вимагає додаткового простору |
| Швидкість | Швидший для більшості операцій | Може потребувати додаткового пошуку |

## Висновок

Некластеризовані індекси – це важливий інструмент оптимізації продуктивності баз даних у SQL Server:
- Вони дозволяють створювати кілька індексів для однієї таблиці
- Не впливають на фізичний порядок даних
- Оптимальні для стовпців, які часто використовуються у WHERE умовах
- Потребують виваженого підходу через додатковий дисковий простір

При проектуванні бази даних важливо визначити, які стовпці потребують індексації та який тип індексу (кластеризований чи некластеризований) буде найбільш ефективним для ваших запитів.




